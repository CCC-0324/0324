<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life - WebGPU Compute Accelerated</title>
  <style>
    body { 
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #050505;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="webgpuCanvas"></canvas>
  <script type="module">
    // --- Configuration and Constants ---
    const PARTICLE_COUNT = 5000;
    const PARTICLE_STRIDE = 4; // x, y, vx, vy (4 * f32)
    const TYPE_COUNT = 12; // Base on your original setup
    const GRID_SIZE = 40; // Spatial Hashing Grid Size

    // Interaction Matrix (12x12 matrix flattened)
    const INTERACTION_MATRIX = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    function randomizeMatrix() {
        for (let i = 0; i < INTERACTION_MATRIX.length; i++) {
            // Values mapped to a range of [-0.2, 0.2] for GPU
            INTERACTION_MATRIX[i] = (Math.random() * 2 - 1) * 0.2; 
        }
    }
    randomizeMatrix(); // Initialize once

    // Particle Color Map (Normalized RGB values for GPU)
    const COLOR_MAP = new Float32Array([
      // Your original colors mapped to 0.0 - 1.0 range
      0.18, 0.27, 0.00, 1.0, 
      0.28, 0.42, 0.00, 1.0, 
      0.64, 0.77, 0.14, 1.0, 
      0.49, 0.52, 0.15, 1.0, 
      0.79, 0.84, 0.53, 1.0, 
      0.31, 0.43, 0.35, 1.0, 
      0.43, 0.55, 0.24, 1.0, 
      0.60, 0.72, 0.60, 1.0, 
      0.33, 0.42, 0.18, 1.0, 
      0.55, 0.59, 0.46, 1.0, 
      0.23, 0.33, 0.14, 1.0, 
      0.71, 0.76, 0.57, 1.0,
    ]);

    // --- GPU Setup Variables ---
    let device, context, presentationFormat;
    let particleBuffers = []; // Dual buffers for ping-pong
    let particleTypesBuffer, matrixBuffer, paramBuffer;
    let computePipeline, renderPipeline;
    let computeBindGroups = [];
    let renderBindGroup;
    let currentBufferIndex = 0;

    // --- Core WebGPU Initialization ---
    async function initWebGPU() {
      if (!navigator.gpu) {
        alert("錯誤: 您的瀏覽器不支持 WebGPU。請使用最新版 Chrome 或 Edge。");
        return;
      }
      const adapter = await navigator.gpu.requestAdapter();
      device = await adapter.requestDevice();

      const canvas = document.getElementById('webgpuCanvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      context = canvas.getContext('webgpu');
      presentationFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device: device,
        format: presentationFormat,
        alphaMode: 'premultiplied', // Need this for the trail effect
      });
      
      // 1. Initialize Particle Data (CPU side)
      const particleData = new Float32Array(PARTICLE_COUNT * PARTICLE_STRIDE);
      const particleTypes = new Uint32Array(PARTICLE_COUNT); // Separate buffer for type for simplicity
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particleData[i * PARTICLE_STRIDE + 0] = Math.random() * canvas.width;  // x
        particleData[i * PARTICLE_STRIDE + 1] = Math.random() * canvas.height; // y
        particleData[i * PARTICLE_STRIDE + 2] = (Math.random() - 0.5);          // vx
        particleData[i * PARTICLE_STRIDE + 3] = (Math.random() - 0.5);          // vy
        particleTypes[i] = Math.floor(Math.random() * TYPE_COUNT);
      }

      // 2. Create GPU Buffers
      const particleBufferSize = particleData.byteLength;
      
      // Ping-pong buffers (Input/Output for Compute)
      for (let i = 0; i < 2; i++) {
        particleBuffers.push(device.createBuffer({
          size: particleBufferSize,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        }));
        // Write initial data to the first buffer
        if (i === 0) {
            device.queue.writeBuffer(particleBuffers[i], 0, particleData);
        }
      }
      
      // Separate buffers for constant data
      particleTypesBuffer = device.createBuffer({
          size: particleTypes.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(particleTypesBuffer, 0, particleTypes);

      matrixBuffer = device.createBuffer({
          size: INTERACTION_MATRIX.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(matrixBuffer, 0, INTERACTION_MATRIX);
      
      paramBuffer = device.createBuffer({
          size: 64, // Sufficient for constants
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });
      
      // 3. Setup Pipelines and Bind Groups
      setupPipelines(canvas.width, canvas.height);
      
      // 4. Update dynamic parameters (e.g., screen size, grid size)
      updateParams(canvas.width, canvas.height);
      
      // 5. Start the loop
      animate();
    }

    function updateParams(w, h) {
        // [width, height, particle_count, type_count, grid_size, max_force, friction, padding]
        const params = new Float32Array([
            w, h, PARTICLE_COUNT, TYPE_COUNT,
            GRID_SIZE, 0.2, 0.68, 0.0, // MAX_FORCE = 0.2, FRICTION = 0.68
            80.0, 50.0, 7.0, 3.0, // NEARBY_RADIUS, INTERACTION_RADIUS, MIN_DIST, MIN_DIST_RIPPLE
            Math.floor(w / GRID_SIZE), Math.floor(h / GRID_SIZE), 0.0, 0.0 // gridCols, gridRows
        ]);
        device.queue.writeBuffer(paramBuffer, 0, params);
    }
    
    // --- WGSL Shaders ---
    
    // The heart of the simulation: Parallel physics update
    const computeShaderWGSL = `
      // System Constants
      struct Params {
        width: f32, height: f32, particle_count: f32, type_count: f32,
        grid_size: f32, max_force: f32, friction: f32, pad1: f32,
        nearby_radius: f32, interaction_radius: f32, min_dist: f32, min_dist_ripple: f32,
        grid_cols: f32, grid_rows: f32, pad2: f32, pad3: f32,
      };

      @group(0) @binding(0) var<storage, read> in_particles: array<vec4<f32>>;  // x, y, vx, vy
      @group(0) @binding(1) var<storage, write> out_particles: array<vec4<f32>>;
      @group(0) @binding(2) var<storage, read> particle_types: array<u32>;
      @group(0) @binding(3) var<uniform> matrix: array<f32>;
      @group(0) @binding(4) var<uniform> params: Params;

      const REPULSION_STRENGTH: f32 = 0.5;

      // Function to sample the interaction matrix (Attraction/Repulsion strength)
      fn get_interaction_force(type_i: u32, type_j: u32) -> f32 {
          let type_count = u32(params.type_count);
          return matrix[type_i * type_count + type_j];
      }

      // Toroidal Distance calculation
      fn toroidal_distance_sq(pos_i: vec2<f32>, pos_j: vec2<f32>) -> vec3<f32> {
          var dx = pos_j.x - pos_i.x;
          var dy = pos_j.y - pos_i.y;
          
          if (dx > params.width * 0.5) { dx -= params.width; }
          else if (dx < -params.width * 0.5) { dx += params.width; }
          
          if (dy > params.height * 0.5) { dy -= params.height; }
          else if (dy < -params.height * 0.5) { dy += params.height; }

          return vec3<f32>(dx, dy, dx*dx + dy*dy); // (dx, dy, distSq)
      }

      // Main Compute Entry Point
      @compute
      @workgroup_size(64) // Threads per workgroup
      fn cs_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        let i = global_id.x;
        if (i >= u32(params.particle_count)) { return; }

        let particle_i = in_particles[i];
        let pos_i = particle_i.xy;
        var vel_i = particle_i.zw;
        let type_i = particle_types[i];
        
        var force = vec2<f32>(0.0, 0.0);
        
        // --- 1. Neighborhood Search (The $O(N)$ part) ---
        // Simplified Spatial Hashing Lookup in Compute Shader
        let gx = i32(pos_i.x / params.grid_size);
        let gy = i32(pos_i.y / params.grid_size);
        
        let grid_cols = i32(params.grid_cols);
        let grid_rows = i32(params.grid_rows);
        let nearby_radius_sq = params.nearby_radius * params.nearby_radius;
        let inter_radius_sq = params.interaction_radius * params.interaction_radius;
        
        // This is a simplified check that still iterates over all other particles (O(N^2))
        // or uses a much more complex pre-calculated grid array (O(N))
        // For demonstration, we use a simple linear check over all particles for maximum parallelism:
        // *** For true performance, a GPU sort and segmented lookup is required, but far too complex for this context. ***
        // *** Here, we rely purely on the GPU's parallel power to handle the high constant factor. ***

        for (var j: u32 = 0; j < u32(params.particle_count); j++) {
            if (i == j) { continue; }

            let particle_j = in_particles[j];
            let type_j = particle_types[j];
            
            // Toroidal distance and squared distance
            let dist_data = toroidal_distance_sq(pos_i, particle_j.xy);
            let dist_sq = dist_data.z;

            if (dist_sq > 0.0 && dist_sq < nearby_radius_sq) {
                let dist = sqrt(dist_sq);
                let dx = dist_data.x;
                let dy = dist_data.y;
                let norm_vec = vec2<f32>(dx / dist, dy / dist); // Normalized direction vector

                let min_dist_sq = params.min_dist * params.min_dist; // Simplified: No ripple logic for now
                
                if (dist_sq < min_dist_sq) {
                    // Repulsion
                    let f = REPULSION_STRENGTH * (1.0 - dist / params.min_dist);
                    force -= f * norm_vec;
                } else {
                    // Attraction/Interaction Force
                    var f = get_interaction_force(type_i, type_j);
                    
                    // Distance Factor
                    f = f / (dist * 0.1); 

                    // Simplified distance modifiers (Close/Interaction)
                    if (dist_sq < 20.0 * 20.0) { f *= -0.2; }
                    else if (dist_sq < inter_radius_sq) { f *= 2.0; }

                    force += f * norm_vec;
                }
            }
        }

        // --- 2. Update Position and Velocity ---
        
        // Apply force
        vel_i += force;

        // Apply friction
        vel_i *= params.friction;

        // Update position
        var next_pos = pos_i + vel_i;

        // Toroidal Wrap (Boundary condition)
        if (next_pos.x < 0.0) { next_pos.x += params.width; }
        else if (next_pos.x >= params.width) { next_pos.x -= params.width; }
        
        if (next_pos.y < 0.0) { next_pos.y += params.height; }
        else if (next_pos.y >= params.height) { next_pos.y -= params.height; }
        
        // Write result to output buffer
        out_particles[i] = vec4<f32>(next_pos.x, next_pos.y, vel_i.x, vel_i.y);
      }
    `;

    // Shader for efficient rendering
    const renderShaderWGSL = `
      // Color Map Buffer (Uniform)
      @group(0) @binding(0) var<uniform> colors: array<vec4<f32>, ${TYPE_COUNT}>;
      
      // Screen Size Buffer (Uniform)
      @group(0) @binding(1) var<uniform> screen_size: vec2<f32>;

      // Particle Position Buffer (Vertex)
      struct VertexInput {
        @location(0) position: vec2<f32>,
        @location(1) type_index: u32,
      };

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) type_index: u32,
      };

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        
        // Convert screen pixel coordinates (0 to width/height) to NDC (-1 to 1)
        let ndc_x = input.position.x / screen_size.x * 2.0 - 1.0;
        let ndc_y = (input.position.y / screen_size.y * 2.0 - 1.0) * -1.0; 
        
        output.position = vec4<f32>(ndc_x, ndc_y, 0.0, 1.0);
        output.type_index = input.type_index;
        
        return output;
      }

      @fragment
      fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
        let color = colors[input.type_index];
        
        // Particle size is handled by Canvas context in this simplified setup.
        // For proper GPU sizing, we would use a geometry shader or instanced quad drawing.
        return color;
      }
    `;
    
    // --- Pipeline Setup ---
    function setupPipelines(width, height) {
      const computeShaderModule = device.createShaderModule({ code: computeShaderWGSL });
      const renderShaderModule = device.createShaderModule({ code: renderShaderWGSL });

      // ** Compute Pipeline (Physics)**
      computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: computeShaderModule,
          entryPoint: 'cs_main',
        },
      });

      // ** Render Pipeline (Drawing)**
      renderPipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: renderShaderModule,
          entryPoint: 'vs_main',
          buffers: [
            { // Particle position buffer
              arrayStride: PARTICLE_STRIDE * 4, // 4 floats * 4 bytes = 16 bytes
              stepMode: 'instance', 
              attributes: [
                { // position: vec2<f32> @location(0) (x, y)
                  shaderLocation: 0, offset: 0, format: 'float32x2',
                },
                // We use the type buffer separately in JS for now, but a full GPU solution would combine them.
                // For simplicity, we create a dummy buffer for type location 1 in the render pipeline
              ],
            },
            { // Type buffer (as a second vertex buffer, accessed by instance)
              arrayStride: 4, // 1 u32 = 4 bytes
              stepMode: 'instance',
              attributes: [{
                  shaderLocation: 1, // type_index: u32 @location(1)
                  offset: 0, format: 'uint32',
              }]
            }
          ],
        },
        fragment: {
          module: renderShaderModule,
          entryPoint: 'fs_main',
          targets: [{
            format: presentationFormat,
            blend: {
                color: {
                    srcFactor: 'src-alpha',
                    dstFactor: 'one-minus-src-alpha',
                    operation: 'add',
                },
                alpha: {
                    srcFactor: 'zero',
                    dstFactor: 'one',
                    operation: 'add',
                }
            }
          }],
        },
        primitive: {
          topology: 'point-list',
        },
      });
      
      // ** Compute Bind Groups (Ping-Pong Setup)**
      for (let i = 0; i < 2; i++) {
        computeBindGroups.push(device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: particleBuffers[i] } },       // Input Buffer
            { binding: 1, resource: { buffer: particleBuffers[1 - i] } },   // Output Buffer
            { binding: 2, resource: { buffer: particleTypesBuffer } },
            { binding: 3, resource: { buffer: matrixBuffer } },
            { binding: 4, resource: { buffer: paramBuffer } },
          ],
        }));
      }

      // ** Render Bind Group **
      renderBindGroup = device.createBindGroup({
        layout: renderPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: device.createBuffer({
              size: COLOR_MAP.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
              mappedAtCreation: true,
            })
          }},
          { binding: 1, resource: { buffer: paramBuffer, size: 8 } }, // Width/Height part of paramBuffer
        ],
      });
      new Float32Array(renderBindGroup.getBindingResource(0).buffer.getMappedRange()).set(COLOR_MAP);
      renderBindGroup.getBindingResource(0).buffer.unmap();
    }

    // --- Main Loop ---

    function animate() {
      // 1. --- Compute Pass (Physics Update) ---
      const computeEncoder = device.createCommandEncoder();
      const computePass = computeEncoder.beginComputePass();
      
      // 

      // Dispatch Compute: Select the current input/output buffers
      const bindGroup = computeBindGroups[currentBufferIndex];
      
      computePass.setPipeline(computePipeline);
      computePass.setBindGroup(0, bindGroup);
      
      // Dispatch one thread per particle (Group size 64)
      const workgroupCount = Math.ceil(PARTICLE_COUNT / 64);
      computePass.dispatchWorkgroups(workgroupCount, 1, 1);
      
      computePass.end();
      
      // 2. --- Render Pass (Drawing) ---
      const renderEncoder = device.createCommandEncoder();
      const passEncoder = renderEncoder.beginRenderPass({
        colorAttachments: [{
          view: context.getCurrentTexture().createView(),
          // Dark background with slight alpha to create the trail effect
          clearValue: { r: 0.03, g: 0.03, b: 0.03, a: 0.3 }, 
          loadOp: 'clear', 
          storeOp: 'store',
        }],
      });

      // Set pipeline and bind groups
      passEncoder.setPipeline(renderPipeline);
      passEncoder.setBindGroup(0, renderBindGroup);
      
      // Bind the current output particle buffer (which is the input for the next frame)
      const renderBufferIndex = 1 - currentBufferIndex;
      passEncoder.setVertexBuffer(0, particleBuffers[renderBufferIndex]); // Position
      passEncoder.setVertexBuffer(1, particleTypesBuffer); // Type
      
      // Draw all particles as points
      passEncoder.draw(1, PARTICLE_COUNT); 

      passEncoder.end();
      
      // 3. Submit Commands & Flip Buffer Index
      device.queue.submit([computeEncoder.finish(), renderEncoder.finish()]);
      currentBufferIndex = 1 - currentBufferIndex; // Flip to the other buffer for the next frame

      requestAnimationFrame(animate);
    }
    
    // Handle Resize (Simplified, requires updating uniforms and context)
    window.addEventListener('resize', () => {
        if (context) {
          const canvas = document.getElementById('webgpuCanvas');
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          context.configure({ size: [canvas.width, canvas.height] });
          updateParams(canvas.width, canvas.height); // Update GPU with new dimensions
        }
    });

    // Start everything
    initWebGPU();
  </script>
</body>
</html>
