<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life - Optimized Toroidal Boundary</title>
  <style>
    body { 
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #050505;
      overflow: hidden;
      font-family: monospace;
    }
    canvas {
      /* Full screen canvas */
    }
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #486B00;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="stats"></div>
  <canvas id="particleCanvas"></canvas>
  <script>
    /**
     * Particle Life - Toroidal Boundary & Optimized Ripple Check
     * Optimization: Ripple checks now use Spatial Hashing to avoid O(N*R) brute force.
     */

    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 

    // Configuration
    let width, height;
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    resize();
    window.addEventListener('resize', resize);

    // Simulation Constants
    const PARTICLE_COUNT = 5000; // 粒子數量維持 5000
    const COLORS = ['#2E4600','#486B00','#A2C523','#7D8427','#C9D787','#4E6E58','#6E8B3D','#99B898','#556B2F','#8E9775','#3B5323','#B4C292'];
    const TYPE_COUNT = COLORS.length;
    
    const COLOR_STRINGS = COLORS; 

    // Physics Constants
    const FRICTION = 0.68;
    const MAX_FORCE = 0.2;
    const REPULSION_STRENGTH = 0.5;
    
    // Distances (Squared for performance)
    const MIN_DIST_SQ = 7 * 7;
    const MIN_DIST_RIPPLE_SQ = 3 * 3;
    const NEARBY_RADIUS = 80;
    const NEARBY_RADIUS_SQ = NEARBY_RADIUS * NEARBY_RADIUS;
    const INTERACTION_RADIUS_SQ = 50 * 50; 
    const CLOSE_RADIUS_SQ = 20 * 20;

    // Grid System Constants
    const GRID_SIZE = 40;
    let gridCols = 0;
    let gridRows = 0;
    
    // --- Data Structures (SoA - Structure of Arrays) ---
    const pX = new Float32Array(PARTICLE_COUNT);
    const pY = new Float32Array(PARTICLE_COUNT);
    const pVX = new Float32Array(PARTICLE_COUNT);
    const pVY = new Float32Array(PARTICLE_COUNT);
    const pType = new Uint8Array(PARTICLE_COUNT);
    const pInRipple = new Uint8Array(PARTICLE_COUNT); // Flag for repulsion change
    
    let gridHead; 
    const gridNext = new Int32Array(PARTICLE_COUNT);

    // Interaction Matrices
    let matrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let targetMatrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    
    // State
    let lastChangeTime = Date.now();
    const CHANGE_INTERVAL = 60000;
    const TRANSITION_DURATION = 30000;
    
    // Ripples
    const ripples = [];
    let lastRippleTime = 0;

    // Dark Matter
    const DARK_MATTER_COUNT = 10;
    const dmX = new Float32Array(DARK_MATTER_COUNT);
    const dmY = new Float32Array(DARK_MATTER_COUNT);
    const dmVX = new Float32Array(DARK_MATTER_COUNT);
    const dmVY = new Float32Array(DARK_MATTER_COUNT);
    const dmActive = new Uint8Array(DARK_MATTER_COUNT);
    const dmBornTime = new Float64Array(DARK_MATTER_COUNT);
    const DM_LIFETIME = 5000;
    const DM_RADIUS_SQ = 30 * 30;

    // --- Initialization ---

    function init() {
      // Initialize Particles
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pX[i] = Math.random() * width;
        pY[i] = Math.random() * height;
        pVX[i] = (Math.random() - 0.5);
        pVY[i] = (Math.random() - 0.5);
        pType[i] = Math.floor(Math.random() * TYPE_COUNT);
      }
      
      // Init Matrix
      randomizeMatrix(matrix);
      targetMatrix.set(matrix);
      
      // Init Grid
      initGrid();
    }

    function initGrid() {
      gridCols = Math.ceil(width / GRID_SIZE);
      gridRows = Math.ceil(height / GRID_SIZE);
      gridHead = new Int32Array(gridCols * gridRows);
    }

    function randomizeMatrix(targetM) {
      for (let i = 0; i < TYPE_COUNT * TYPE_COUNT; i++) {
        targetM[i] = Math.random() * 2 * MAX_FORCE - MAX_FORCE;
      }
    }

    // --- Core Logic ---

    function updateMatrix() {
      const now = Date.now();
      const dt = now - lastChangeTime;
      
      // Matrix Transition
      if (now - lastChangeTime > CHANGE_INTERVAL) {
        matrix.set(targetMatrix);
        randomizeMatrix(targetMatrix);
        lastChangeTime = now;
      } else if (dt < TRANSITION_DURATION) {
        for (let i = 0; i < matrix.length; i++) {
           matrix[i] += (targetMatrix[i] - matrix[i]) * 0.01; 
        }
      }
    }

    function updatePhysics() {
      // 1. Reset Grid
      gridHead.fill(-1);
      // Reset Ripple flags for all particles
      pInRipple.fill(0); 

      // 2. Move Particles & Insert into Grid
      for (let i = 0; i < PARTICLE_COUNT; i++) {

        // Apply velocity
        pX[i] += pVX[i];
        pY[i] += pVY[i];

        // --- TOROIDAL WRAP BOUNDARY (Full Screen) ---
        if (pX[i] < 0) pX[i] += width;
        else if (pX[i] >= width) pX[i] -= width;
        
        if (pY[i] < 0) pY[i] += height;
        else if (pY[i] >= height) pY[i] -= height;
        // ---------------------------------------------

        // Friction
        pVX[i] *= FRICTION;
        pVY[i] *= FRICTION;

        // Grid Insertion
        const gx = (pX[i] / GRID_SIZE) | 0; 
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        // Due to wrapping, particles are always in valid range (0 to width/height-epsilon)
        const cellId = gy * gridCols + gx;
        gridNext[i] = gridHead[cellId];
        gridHead[cellId] = i;
      }

      // 3. Ripple & Dark Matter Logic (Optimized for Ripple Marking)
      const now = Date.now();
      
      // Update Ripples (Visual part)
      for (let r = ripples.length - 1; r >= 0; r--) {
        const ripple = ripples[r];
        ripple.radius += 2;
        ripple.opacity -= 0.01;
        
        if (ripple.opacity <= 0) {
          ripples.splice(r, 1);
          continue;
        }
      }
      
      // --- OPTIMIZED RIPPLE PARTICLE MARKING (Using Spatial Grid) ---
      if (ripples.length > 0) {
         for (const r of ripples) {
            // Calculate grid bounds covered by the ripple
            // Using Math.floor/ceil to ensure we cover the entire circular area
            const minX = Math.max(0, Math.floor((r.x - r.radius) / GRID_SIZE));
            const maxX = Math.min(gridCols - 1, Math.ceil((r.x + r.radius) / GRID_SIZE));
            const minY = Math.max(0, Math.floor((r.y - r.radius) / GRID_SIZE));
            const maxY = Math.min(gridRows - 1, Math.ceil((r.y + r.radius) / GRID_SIZE));

            // Iterate over the grid cells covered by the ripple
            for (let ny = minY; ny <= maxY; ny++) {
               for (let nx = minX; nx <= maxX; nx++) {
                  const cellId = ny * gridCols + nx;
                  let j = gridHead[cellId];
                  
                  // Traverse Linked List in this cell
                  while (j !== -1) {
                     const dx = pX[j] - r.x;
                     const dy = pY[j] - r.y;
                     
                     // Check if particle is actually within the circle's radius
                     if (dx*dx + dy*dy < r.radius * r.radius) {
                       pInRipple[j] = 1; // Mark particle
                     }
                     j = gridNext[j];
                  }
               }
            }
         }
      }
      // -------------------------------------------------------------


      // Update Dark Matter (Boundary behavior kept as bounce)
      for (let i = 0; i < DARK_MATTER_COUNT; i++) {
        if (dmActive[i] === 0) continue;
        
        // Move
        dmX[i] += dmVX[i];
        dmY[i] += dmVY[i];
        
        // Bounce
        if (dmX[i] < 0) { dmX[i] = 0; dmVX[i] *= -1; }
        if (dmX[i] > width) { dmX[i] = width; dmVX[i] *= -1; }
        if (dmY[i] < 0) { dmY[i] = 0; dmVY[i] *= -1; }
        if (dmY[i] > height) { dmY[i] = height; dmVY[i] *= -1; }

        // Chaos move
        dmVX[i] += (Math.random() - 0.5) * 2;
        dmVY[i] += (Math.random() - 0.5) * 2;
        
        // Limit speed
        const speed = Math.sqrt(dmVX[i]**2 + dmVY[i]**2);
        if (speed > 10) { dmVX[i] = (dmVX[i]/speed)*10; dmVY[i] = (dmVY[i]/speed)*10; }

        // Lifetime
        const age = now - dmBornTime[i];
        if (age > DM_LIFETIME) {
          dmActive[i] = 0;
        }
      }

      // 4. Calculate Forces 
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const typeI = pType[i];
        const rowOffset = typeI * TYPE_COUNT;
        
        const gx = (pX[i] / GRID_SIZE) | 0;
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        // Neighbor Search (3x3 grid)
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            // Need to wrap the grid index to search cells on the opposite side
            const nx = (gx + dx + gridCols) % gridCols;
            const ny = (gy + dy + gridRows) % gridRows;
            
            // Due to wrapping, no need for if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows)
            const cellId = ny * gridCols + nx;
            let j = gridHead[cellId];
            
            // Traverse Linked List in this cell
            while (j !== -1) {
              if (i !== j) {
                let dxVal = pX[j] - pX[i];
                let dyVal = pY[j] - pY[i];
                
                // --- TOROIDAL WRAP DISTANCE ADJUSTMENT ---
                if (dxVal > width * 0.5) dxVal -= width;
                else if (dxVal < -width * 0.5) dxVal += width;
                
                if (dyVal > height * 0.5) dyVal -= height;
                else if (dyVal < -height * 0.5) dyVal += height;
                // -----------------------------------------
                
                const distSq = dxVal*dxVal + dyVal*dyVal;
                
                if (distSq > 0 && distSq < NEARBY_RADIUS_SQ) {
                  const dist = Math.sqrt(distSq);
                  
                  let fx = 0, fy = 0;
                  
                  // Repulsion (Strength changes if particle is marked by a ripple)
                  const minDistSq = pInRipple[i] ? MIN_DIST_RIPPLE_SQ : MIN_DIST_SQ;
                  
                  if (distSq < minDistSq) {
                    const force = REPULSION_STRENGTH * (1.0 - dist / Math.sqrt(minDistSq));
                    fx -= force * (dxVal / dist);
                    fy -= force * (dyVal / dist);
                  } else {
                    // Interaction Force
                    const typeJ = pType[j];
                    let force = matrix[rowOffset + typeJ];
                    
                    // Distance Factor
                    force = force / (dist * 0.1); 

                    if (distSq < CLOSE_RADIUS_SQ) force *= -0.2;
                    else if (distSq < INTERACTION_RADIUS_SQ) force *= 2;

                    fx += force * (dxVal / dist);
                    fy += force * (dyVal / dist);
                  }
                  
                  pVX[i] += fx;
                  pVY[i] += fy;
                }
              }
              j = gridNext[j];
            }
          }
        }
        
        // Dark Matter Repulsion
        for (let d = 0; d < DARK_MATTER_COUNT; d++) {
           if (dmActive[d]) {
             let dx = dmX[d] - pX[i];
             let dy = dmY[d] - pY[i];
             let dSq = dx*dx + dy*dy;
             if (dSq < DM_RADIUS_SQ) {
               let dist = Math.sqrt(dSq);
               let rep = 2.0;
               pVX[i] -= (dx/dist) * rep;
               pVY[i] -= (dy/dist) * rep;
             }
           }
        }
      }

      // Randomly spawn Ripples & Dark Matter
      if (now - lastRippleTime > 4000 && Math.random() < 0.05) {
         const rI = Math.floor(Math.random() * PARTICLE_COUNT);
         ripples.push({x: pX[rI], y: pY[rI], radius: 0, opacity: 0.8});
         lastRippleTime = now;
         
         for(let d=0; d<DARK_MATTER_COUNT; d++){
           if(!dmActive[d]) {
             dmActive[d] = 1;
             dmX[d] = pX[rI];
             dmY[d] = pY[rI];
             dmVX[d] = (Math.random()-0.5)*10;
             dmVY[d] = (Math.random()-0.5)*10;
             dmBornTime[d] = now;
             break;
           }
         }
      }
    }

    function draw() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw Ripples
      ctx.lineWidth = 2;
      for (const r of ripples) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(50, 80, 50, ${r.opacity})`;
        ctx.stroke();
      }

      // Draw Dark Matter
      ctx.fillStyle = "#000000";
      for(let i=0; i<DARK_MATTER_COUNT; i++){
        if(dmActive[i]) {
          ctx.beginPath();
          ctx.arc(dmX[i], dmY[i], 4, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "#000000";
          ctx.stroke();
        }
      }

      // Draw Particles (Optimized)
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        ctx.fillStyle = COLOR_STRINGS[pType[i]];
        ctx.fillRect(pX[i], pY[i], 2, 2); 
      }
    }

    function animate() {
      updateMatrix();
      updatePhysics();
      draw();
      requestAnimationFrame(animate);
    }

    // Handle Window Resize re-init grid
    window.addEventListener('resize', () => {
        resize();
        initGrid();
    });

    // Start
    init();
    animate();

    // Click for Fullscreen
    canvas.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    });

  </script>
</body>
</html>
