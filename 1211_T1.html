<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>GPGPU Particle Life - High Performance</title>
  <style>
    body {
      margin: 0;
      background-color: #000;
      overflow: hidden;
      font-family: monospace;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #486B00;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 5px;
    }
  </style>
</head>
<body>
  <div id="stats">GPU Mode | Particles: 16384</div>
  <canvas id="glCanvas"></canvas>

  <script id="vs-quad" type="x-shader/x-vertex">#version 300 es
    in vec4 a_position;
    out vec2 v_uv;
    void main() {
      v_uv = a_position.xy * 0.5 + 0.5;
      gl_Position = a_position;
    }
  </script>

  <script id="fs-physics" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    // 輸入紋理
    uniform sampler2D u_posTex; // (x, y, type, 0)
    uniform sampler2D u_velTex; // (vx, vy, 0, 0)
    
    // 參數
    uniform vec2 u_resolution;
    uniform float u_matrix[144]; // 12x12 flattened
    uniform float u_dt;
    uniform float u_friction;
    uniform vec2 u_worldSize; // 0..1 normalized usually, but we calculate forces in normalized space
    
    // 特殊事件
    struct Ripple { vec2 pos; float radius; float active; };
    uniform Ripple u_ripples[4];
    
    struct DarkMatter { vec2 pos; float active; };
    uniform DarkMatter u_darkMatter[10];

    // 輸出
    layout(location = 0) out vec4 out_newPos;
    layout(location = 1) out vec4 out_newVel;

    in vec2 v_uv;

    // 常數
    const float MAX_FORCE = 0.2; // Adjusted for normalized space
    const float R_SMOOTH = 0.01; 
    
    void main() {
      // 讀取自身狀態
      vec4 pSelf = texture(u_posTex, v_uv);
      vec4 vSelf = texture(u_velTex, v_uv);
      
      vec2 pos = pSelf.xy;
      vec2 vel = vSelf.xy;
      int myType = int(pSelf.z);

      // --- 力學計算 ---
      vec2 force = vec2(0.0);
      
      // 1. 粒子間交互 (暴力循環：採樣整張紋理)
      // 注意：為了效能，我們在這裡假設紋理大小是 128x128
      ivec2 texSize = textureSize(u_posTex, 0);
      
      for (int y = 0; y < 128; y++) {
        for (int x = 0; x < 128; x++) {
           vec4 pOther = texelFetch(u_posTex, ivec2(x, y), 0);
           
           // 自己不跟自己互動
           if (pOther.xy == pos) continue;

           vec2 d = pOther.xy - pos;

           // Toroidal Wrap Distance (0..1 domain)
           if (d.x > 0.5) d.x -= 1.0;
           else if (d.x < -0.5) d.x += 1.0;
           if (d.y > 0.5) d.y -= 1.0;
           else if (d.y < -0.5) d.y += 1.0;

           float distSq = dot(d, d);
           
           // 物理半徑參數 (歸一化空間)
           // 假設螢幕寬度 1000px, 原代碼半徑 80 => 0.08
           // 為了視覺效果，這裡重新調整參數
           float nearbyRadiusSq = 0.0064; // 0.08^2
           float minDistSq = 0.00005;     // 防止除以零與過強斥力

           if (distSq > 0.0 && distSq < nearbyRadiusSq) {
              float dist = sqrt(distSq);
              float dx = d.x / dist;
              float dy = d.y / dist;
              
              int otherType = int(pOther.z);
              
              // 查詢矩陣力
              float f = u_matrix[myType * 12 + otherType];
              
              // 斥力與引力
              // 原理：如果非常近，強制斥力；否則根據矩陣
              if (distSq < minDistSq) {
                 float rep = 2.0 * (1.0 - dist / sqrt(minDistSq));
                 force -= vec2(dx, dy) * rep;
              } else {
                 // 簡化的引力衰減
                 float factor = f * (1.0 - dist / sqrt(nearbyRadiusSq));
                 force += vec2(dx, dy) * factor; 
              }
           }
        }
      }

      // 2. 漣漪影響
      for(int i=0; i<4; i++) {
        if(u_ripples[i].active > 0.5) {
          vec2 rd = pos - u_ripples[i].pos;
          // Wrap
          if (rd.x > 0.5) rd.x -= 1.0; else if (rd.x < -0.5) rd.x += 1.0;
          if (rd.y > 0.5) rd.y -= 1.0; else if (rd.y < -0.5) rd.y += 1.0;
          
          float rDist = length(rd);
          if (rDist < u_ripples[i].radius) {
             // 被漣漪掃到，稍微推開
             force += normalize(rd) * 0.5;
          }
        }
      }

      // 3. 暗物質
      for(int i=0; i<10; i++) {
        if(u_darkMatter[i].active > 0.5) {
          vec2 dd = u_darkMatter[i].pos - pos;
           // Wrap logic not applied to DM in original, but interaction needs relative vector
           // DM usually bounces, particles wrap. Let's keep simpler logic here.
           if (dd.x > 0.5) dd.x -= 1.0; else if (dd.x < -0.5) dd.x += 1.0;
           if (dd.y > 0.5) dd.y -= 1.0; else if (dd.y < -0.5) dd.y += 1.0;
           
           float dmDistSq = dot(dd, dd);
           if (dmDistSq < 0.002) {
             float dist = sqrt(dmDistSq);
             force -= (dd / dist) * 2.0; // 強烈斥力
           }
        }
      }

      // 整合速度
      vel += force * 0.0005; // Time step factor
      vel *= u_friction;

      // 移動位置
      pos += vel;

      // 邊界 Wrap (0..1)
      pos = fract(pos);

      out_newPos = vec4(pos, pSelf.z, 1.0);
      out_newVel = vec4(vel, 0.0, 1.0);
    }
  </script>

  <script id="vs-render" type="x-shader/x-vertex">#version 300 es
    in vec2 a_texCoord; // 每個粒子的 ID 對應紋理座標
    
    uniform sampler2D u_posTex;
    uniform vec3 u_colors[12];
    
    out vec3 v_color;

    void main() {
      vec4 data = texture(u_posTex, a_texCoord);
      vec2 pos = data.xy;
      int type = int(data.z);

      // 轉換 0..1 到 Clip Space -1..1
      vec2 clipPos = pos * 2.0 - 1.0;
      
      // 根據 Y 軸翻轉 (Canvas 座標與 GL 座標差異)
      clipPos.y *= -1.0;

      gl_Position = vec4(clipPos, 0.0, 1.0);
      gl_PointSize = 2.0; // 粒子大小
      
      v_color = u_colors[type];
    }
  </script>

  <script id="fs-render" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    in vec3 v_color;
    out vec4 outColor;
    void main() {
      outColor = vec4(v_color, 1.0);
    }
  </script>

  <script id="fs-fade" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    out vec4 outColor;
    void main() {
      // 黑色，透明度 0.2 (模擬原始的 0.3 + 疊加)
      outColor = vec4(0.0, 0.0, 0.0, 0.2);
    }
  </script>

  <script>
    /** * GPGPU Particle Life
     * 16384 Particles (128x128 Texture)
     */
     
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl2', { alpha: false });
    
    if (!gl) {
        alert("WebGL 2 not supported. Please use a modern browser.");
    }

    // 擴充功能：浮點數紋理 (必要)
    const ext = gl.getExtension("EXT_color_buffer_float");
    if (!ext) alert("Need EXT_color_buffer_float");

    // --- 設定 ---
    const TEX_SIZE = 128; // 128x128 = 16384 粒子 (若顯卡強可改 256)
    const PARTICLE_COUNT = TEX_SIZE * TEX_SIZE;
    const TYPE_COUNT = 12;
    
    // 顏色定義 (轉換為 normalized float 0-1)
    const HEX_COLORS = ['#2E4600','#486B00','#A2C523','#7D8427','#C9D787','#4E6E58','#6E8B3D','#99B898','#556B2F','#8E9775','#3B5323','#B4C292'];
    const GL_COLORS = new Float32Array(TYPE_COUNT * 3);
    
    HEX_COLORS.forEach((hex, i) => {
        const bigint = parseInt(hex.slice(1), 16);
        const r = ((bigint >> 16) & 255) / 255;
        const g = ((bigint >> 8) & 255) / 255;
        const b = (bigint & 255) / 255;
        GL_COLORS[i*3+0] = r;
        GL_COLORS[i*3+1] = g;
        GL_COLORS[i*3+2] = b;
    });

    // --- 程式編譯輔助函式 ---
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSrc, fsSrc) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return null;
      }
      return prog;
    }

    // --- Shader 初始化 ---
    const quadVS = document.getElementById('vs-quad').textContent;
    const physicsFS = document.getElementById('fs-physics').textContent;
    const renderVS = document.getElementById('vs-render').textContent;
    const renderFS = document.getElementById('fs-render').textContent;
    const fadeFS = document.getElementById('fs-fade').textContent;

    const physicsProg = createProgram(gl, quadVS, physicsFS);
    const renderProg = createProgram(gl, renderVS, renderFS);
    const fadeProg = createProgram(gl, quadVS, fadeFS);

    // --- Buffer Setup ---
    
    // 1. 全螢幕 Quad (用於跑 Physics 和 Fade)
    const quadVao = gl.createVertexArray();
    gl.bindVertexArray(quadVao);
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); // a_position
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // 2. 粒子渲染 ID (用於 Vertex Shader 查找 Texture)
    const particlesVao = gl.createVertexArray();
    gl.bindVertexArray(particlesVao);
    const ids = new Float32Array(PARTICLE_COUNT * 2);
    for (let y = 0; y < TEX_SIZE; y++) {
        for (let x = 0; x < TEX_SIZE; x++) {
            const i = y * TEX_SIZE + x;
            ids[i * 2 + 0] = (x + 0.5) / TEX_SIZE; // U
            ids[i * 2 + 1] = (y + 0.5) / TEX_SIZE; // V
        }
    }
    const idBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, idBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, ids, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0); // a_texCoord
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // --- Texture & Framebuffer 初始化 (Ping-Pong) ---
    function createDataTexture(data) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, TEX_SIZE, TEX_SIZE, 0, gl.RGBA, gl.FLOAT, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return tex;
    }

    // 初始資料
    const initialPos = new Float32Array(PARTICLE_COUNT * 4);
    const initialVel = new Float32Array(PARTICLE_COUNT * 4);
    for(let i=0; i<PARTICLE_COUNT; i++) {
        initialPos[i*4+0] = Math.random(); // X (0..1)
        initialPos[i*4+1] = Math.random(); // Y (0..1)
        initialPos[i*4+2] = Math.floor(Math.random() * TYPE_COUNT); // Type
        
        initialVel[i*4+0] = (Math.random() - 0.5) * 0.001;
        initialVel[i*4+1] = (Math.random() - 0.5) * 0.001;
    }

    const posTex1 = createDataTexture(initialPos);
    const posTex2 = createDataTexture(null);
    const velTex1 = createDataTexture(initialVel);
    const velTex2 = createDataTexture(null);

    // 建立兩個 FBO 進行交換
    // FBO1: 寫入到 posTex1, velTex1
    const fbo1 = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, posTex1, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, velTex1, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

    // FBO2: 寫入到 posTex2, velTex2
    const fbo2 = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, posTex2, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, velTex2, 0);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // --- 狀態變數 ---
    let frame = 0;
    let matrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let targetMatrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let lastChangeTime = Date.now();
    
    // 暗物質與漣漪 (CPU 端的資料，傳給 GPU)
    const ripples = []; 
    const darkMatter = [];
    for(let i=0; i<10; i++) darkMatter.push({x:0, y:0, vx:0, vy:0, active:0});
    
    function randomizeMatrix(m) {
        for(let i=0; i<m.length; i++) m[i] = (Math.random() * 2 - 1) * 0.5; // Force -0.5 to 0.5
    }
    randomizeMatrix(matrix);
    targetMatrix.set(matrix);

    // --- Resize ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 主迴圈 ---
    function updateMatrixLogic() {
        const now = Date.now();
        if (now - lastChangeTime > 60000) {
            matrix.set(targetMatrix);
            randomizeMatrix(targetMatrix);
            lastChangeTime = now;
        } else {
             // 簡單插值
             for(let i=0; i<matrix.length; i++) {
                 matrix[i] += (targetMatrix[i] - matrix[i]) * 0.01;
             }
        }
    }

    function updateRipplesAndDarkMatter() {
        // 更新 Ripples
        for(let i=ripples.length-1; i>=0; i--) {
            ripples[i].radius += 0.003; // Normalize speed
            ripples[i].life -= 0.01;
            if(ripples[i].life <= 0) ripples.splice(i, 1);
        }

        // 隨機產生
        if(Math.random() < 0.01) {
            ripples.push({x: Math.random(), y: Math.random(), radius: 0, life: 1.0});
            if(ripples.length > 4) ripples.shift();
        }

        // 更新 Dark Matter
        // 簡單模擬，讓它們在 CPU 端跑，然後把位置傳給 Shader
        darkMatter.forEach(dm => {
            if(dm.active) {
                dm.x += dm.vx; 
                dm.y += dm.vy;
                if(dm.x<0 || dm.x>1) { dm.vx *= -1; dm.x = Math.max(0, Math.min(1, dm.x)); }
                if(dm.y<0 || dm.y>1) { dm.vy *= -1; dm.y = Math.max(0, Math.min(1, dm.y)); }
                dm.life -= 1;
                if(dm.life <= 0) dm.active = 0;
            } else if(Math.random() < 0.005) {
                // Respawn
                dm.active = 1;
                dm.life = 600;
                dm.x = Math.random();
                dm.y = Math.random();
                dm.vx = (Math.random()-0.5)*0.005;
                dm.vy = (Math.random()-0.5)*0.005;
            }
        });
    }

    function loop() {
        updateMatrixLogic();
        updateRipplesAndDarkMatter();

        const readFBO = (frame % 2 === 0) ? fbo1 : fbo2;
        const writeFBO = (frame % 2 === 0) ? fbo2 : fbo1;
        const readPos = (frame % 2 === 0) ? posTex1 : posTex2;
        const readVel = (frame % 2 === 0) ? velTex1 : velTex2;

        // 1. 物理步驟 (Render to Texture)
        gl.bindFramebuffer(gl.FRAMEBUFFER, writeFBO);
        gl.viewport(0, 0, TEX_SIZE, TEX_SIZE); // Viewport 必須對應紋理大小
        gl.useProgram(physicsProg);

        // Bind Textures
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, readPos);
        gl.uniform1i(gl.getUniformLocation(physicsProg, "u_posTex"), 0);
        
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, readVel);
        gl.uniform1i(gl.getUniformLocation(physicsProg, "u_velTex"), 1);

        // Uniforms
        gl.uniform1fv(gl.getUniformLocation(physicsProg, "u_matrix"), matrix);
        gl.uniform1f(gl.getUniformLocation(physicsProg, "u_friction"), 0.85); // 調整摩擦力

        // Upload Ripples
        for(let i=0; i<4; i++) {
            const r = ripples[i];
            const locPos = gl.getUniformLocation(physicsProg, `u_ripples[${i}].pos`);
            const locRad = gl.getUniformLocation(physicsProg, `u_ripples[${i}].radius`);
            const locAct = gl.getUniformLocation(physicsProg, `u_ripples[${i}].active`);
            if(r) {
                gl.uniform2f(locPos, r.x, r.y);
                gl.uniform1f(locRad, r.radius);
                gl.uniform1f(locAct, 1.0);
            } else {
                gl.uniform1f(locAct, 0.0);
            }
        }
        
        // Upload Dark Matter
        for(let i=0; i<10; i++) {
            const d = darkMatter[i];
            const locPos = gl.getUniformLocation(physicsProg, `u_darkMatter[${i}].pos`);
            const locAct = gl.getUniformLocation(physicsProg, `u_darkMatter[${i}].active`);
            if(d && d.active) {
                gl.uniform2f(locPos, d.x, d.y);
                gl.uniform1f(locAct, 1.0);
            } else {
                gl.uniform1f(locAct, 0.0);
            }
        }

        // Draw Full Quad for Computation
        gl.bindVertexArray(quadVao);
        gl.drawArrays(gl.TRIANGLES, 0, 6);


        // 2. 渲染步驟 (Render to Screen)
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);

        // A. 畫半透明黑底 (Fade Effect)
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(fadeProg);
        gl.bindVertexArray(quadVao);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.disable(gl.BLEND); // 畫粒子時不 Blend，或者 Blend Additive 看個人喜好
        
        // B. 畫粒子
        gl.useProgram(renderProg);
        
        // 使用剛剛算好的位置 (writeFBO 的附件0 - 雖然它是 FBO，但其背後的 Texture 可讀)
        const newPosTex = (frame % 2 === 0) ? posTex2 : posTex1; // 剛寫入的
        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, newPosTex);
        gl.uniform1i(gl.getUniformLocation(renderProg, "u_posTex"), 0);
        
        gl.uniform3fv(gl.getUniformLocation(renderProg, "u_colors"), GL_COLORS);

        gl.bindVertexArray(particlesVao);
        gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);

        frame++;
        requestAnimationFrame(loop);
    }
    
    // Start
    loop();

  </script>
</body>
</html>