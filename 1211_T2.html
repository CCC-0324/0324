<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life - WebGL</title>
  <style>
    body { 
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000000;
      overflow: hidden;
      font-family: monospace;
    }
    canvas {
      display: block;
    }
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #486B00;
      pointer-events: none;
      font-size: 14px;
      text-shadow: 1px 1px 2px black;
    }
  </style>
</head>
<body>
  <div id="stats"></div>
  <canvas id="particleCanvas"></canvas>
  <script>
    const canvas = document.getElementById('particleCanvas');
    const gl = canvas.getContext('webgl', { 
      alpha: false,
      antialias: false,
      powerPreference: 'high-performance'
    }) || canvas.getContext('experimental-webgl');

    if (!gl) {
      alert('WebGL not supported! Falling back to Canvas 2D...');
      // Fallback to original implementation
      window.location.reload();
      throw new Error('WebGL not supported');
    }

    // Configuration
    let width, height;
    const PARTICLE_COUNT = 15000; // Optimized for WebGL 1.0
    const COLORS = [
      [0.18, 0.27, 0.00], // #2E4600
      [0.28, 0.42, 0.00], // #486B00
      [0.64, 0.77, 0.14], // #A2C523
      [0.49, 0.52, 0.15], // #7D8427
      [0.79, 0.84, 0.53], // #C9D787
      [0.31, 0.43, 0.35], // #4E6E58
      [0.43, 0.55, 0.24], // #6E8B3D
      [0.60, 0.72, 0.60], // #99B898
      [0.34, 0.42, 0.18], // #556B2F
      [0.56, 0.59, 0.46], // #8E9775
      [0.23, 0.33, 0.14], // #3B5323
      [0.71, 0.76, 0.57]  // #B4C292
    ];
    const TYPE_COUNT = COLORS.length;

    // Physics Constants
    const FRICTION = 0.68;
    const MAX_FORCE = 0.2;
    const REPULSION_STRENGTH = 0.5;
    const MIN_DIST = 7.0;
    const MIN_DIST_RIPPLE = 3.0;
    const NEARBY_RADIUS = 80.0;
    const INTERACTION_RADIUS = 50.0;
    const CLOSE_RADIUS = 20.0;

    // Grid System
    const GRID_SIZE = 40;
    let gridCols = 0;
    let gridRows = 0;

    // Dark Matter
    const DARK_MATTER_COUNT = 10;
    const DM_LIFETIME = 5000;
    const DM_RADIUS = 30.0;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0, 0, width, height);
      gridCols = Math.ceil(width / GRID_SIZE);
      gridRows = Math.ceil(height / GRID_SIZE);
    }
    resize();
    window.addEventListener('resize', resize);

    // ============ SHADER PROGRAMS ============

    // Particle Render Shader (WebGL 1.0)
    const particleVertexShader = `
    attribute vec2 a_position;
    attribute vec3 a_color;
    
    uniform vec2 u_resolution;
    
    varying vec3 v_color;
    
    void main() {
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace, 0.0, 1.0);
      gl_PointSize = 2.0;
      v_color = a_color;
    }
    `;

    const particleFragmentShader = `
    precision mediump float;
    
    varying vec3 v_color;
    
    void main() {
      gl_FragColor = vec4(v_color, 1.0);
    }
    `;

    // Trail Effect Shader
    const trailVertexShader = `
    attribute vec2 a_position;
    varying vec2 v_texCoord;
    
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_position * 0.5 + 0.5;
      v_texCoord.y = 1.0 - v_texCoord.y;
    }
    `;

    const trailFragmentShader = `
    precision mediump float;
    
    varying vec2 v_texCoord;
    uniform sampler2D u_texture;
    
    void main() {
      vec4 color = texture2D(u_texture, v_texCoord);
      gl_FragColor = color * 0.97;
    }
    `;

    // Dark Matter Shader
    const dmVertexShader = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    
    void main() {
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      clipSpace.y = -clipSpace.y;
      gl_Position = vec4(clipSpace, 0.0, 1.0);
      gl_PointSize = 8.0;
    }
    `;

    const dmFragmentShader = `
    precision mediump float;
    
    void main() {
      vec2 coord = gl_PointCoord - vec2(0.5);
      float dist = length(coord);
      if (dist > 0.5) discard;
      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.8);
    }
    `;

    // ============ SHADER COMPILATION ============
    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(vsSource, fsSource) {
      const vs = compileShader(vsSource, gl.VERTEX_SHADER);
      const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    // Create all programs
    const particleProgram = createProgram(particleVertexShader, particleFragmentShader);
    const trailProgram = createProgram(trailVertexShader, trailFragmentShader);
    const dmProgram = createProgram(dmVertexShader, dmFragmentShader);

    // ============ BUFFERS & DATA ============

    // Particle Data (CPU side)
    const pX = new Float32Array(PARTICLE_COUNT);
    const pY = new Float32Array(PARTICLE_COUNT);
    const pVX = new Float32Array(PARTICLE_COUNT);
    const pVY = new Float32Array(PARTICLE_COUNT);
    const pType = new Uint8Array(PARTICLE_COUNT);
    const pInRipple = new Uint8Array(PARTICLE_COUNT);

    // GPU Buffers
    const positionBuffer = gl.createBuffer();
    const colorBuffer = gl.createBuffer();
    const dmBuffer = gl.createBuffer();

    // Interaction Matrix
    let matrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let targetMatrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);

    // Grid System
    let gridHead = new Int32Array(gridCols * gridRows);
    const gridNext = new Int32Array(PARTICLE_COUNT);

    // State
    let lastChangeTime = Date.now();
    const CHANGE_INTERVAL = 60000;
    const TRANSITION_DURATION = 30000;

    // Ripples
    const ripples = [];
    let lastRippleTime = 0;

    // Dark Matter
    const dmX = new Float32Array(DARK_MATTER_COUNT);
    const dmY = new Float32Array(DARK_MATTER_COUNT);
    const dmVX = new Float32Array(DARK_MATTER_COUNT);
    const dmVY = new Float32Array(DARK_MATTER_COUNT);
    const dmActive = new Uint8Array(DARK_MATTER_COUNT);
    const dmBornTime = new Float64Array(DARK_MATTER_COUNT);

    // Framebuffers for trail effect
    let trailFB1, trailFB2, trailTex1, trailTex2;
    let currentTrailFB = 0;

    function initTrailFramebuffers() {
      // Create textures
      trailTex1 = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, trailTex1);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      trailTex2 = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, trailTex2);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // Create framebuffers
      trailFB1 = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, trailFB1);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, trailTex1, 0);

      trailFB2 = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, trailFB2);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, trailTex2, 0);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    // Full-screen quad for trail effect
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,  1, -1,  -1, 1,
      -1, 1,   1, -1,   1, 1
    ]), gl.STATIC_DRAW);

    // ============ INITIALIZATION ============

    function init() {
      // Initialize Particles
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pX[i] = Math.random() * width;
        pY[i] = Math.random() * height;
        pVX[i] = (Math.random() - 0.5);
        pVY[i] = (Math.random() - 0.5);
        pType[i] = Math.floor(Math.random() * TYPE_COUNT);
      }

      randomizeMatrix(matrix);
      targetMatrix.set(matrix);

      initTrailFramebuffers();

      // Clear initial framebuffers
      gl.bindFramebuffer(gl.FRAMEBUFFER, trailFB1);
      gl.clearColor(0.02, 0.02, 0.02, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, trailFB2);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function randomizeMatrix(targetM) {
      for (let i = 0; i < TYPE_COUNT * TYPE_COUNT; i++) {
        targetM[i] = Math.random() * 2 * MAX_FORCE - MAX_FORCE;
      }
    }

    // ============ UPDATE LOGIC ============

    function updateMatrix() {
      const now = Date.now();
      const dt = now - lastChangeTime;

      if (now - lastChangeTime > CHANGE_INTERVAL) {
        matrix.set(targetMatrix);
        randomizeMatrix(targetMatrix);
        lastChangeTime = now;
      } else if (dt < TRANSITION_DURATION) {
        for (let i = 0; i < matrix.length; i++) {
          matrix[i] += (targetMatrix[i] - matrix[i]) * 0.01;
        }
      }
    }

    function updatePhysics() {
      gridHead.fill(-1);

      // Move particles & insert into grid
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pInRipple[i] = 0;

        pX[i] += pVX[i];
        pY[i] += pVY[i];

        // Toroidal wrap
        if (pX[i] < 0) pX[i] += width;
        else if (pX[i] >= width) pX[i] -= width;
        if (pY[i] < 0) pY[i] += height;
        else if (pY[i] >= height) pY[i] -= height;

        pVX[i] *= FRICTION;
        pVY[i] *= FRICTION;

        const gx = (pX[i] / GRID_SIZE) | 0;
        const gy = (pY[i] / GRID_SIZE) | 0;

        if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows) {
          const cellId = gy * gridCols + gx;
          gridNext[i] = gridHead[cellId];
          gridHead[cellId] = i;
        } else {
          gridNext[i] = -1;
        }
      }

      const now = Date.now();

      // Update Ripples
      for (let r = ripples.length - 1; r >= 0; r--) {
        const ripple = ripples[r];
        ripple.radius += 2;
        ripple.opacity -= 0.01;

        if (ripple.opacity <= 0) {
          ripples.splice(r, 1);
          continue;
        }
      }

      // Mark particles in ripples (optimized with grid)
      if (ripples.length > 0) {
        for (let r of ripples) {
          const minGx = Math.max(0, Math.floor((r.x - r.radius) / GRID_SIZE));
          const maxGx = Math.min(gridCols - 1, Math.floor((r.x + r.radius) / GRID_SIZE));
          const minGy = Math.max(0, Math.floor((r.y - r.radius) / GRID_SIZE));
          const maxGy = Math.min(gridRows - 1, Math.floor((r.y + r.radius) / GRID_SIZE));

          for (let gy = minGy; gy <= maxGy; gy++) {
            for (let gx = minGx; gx <= maxGx; gx++) {
              const cellId = gy * gridCols + gx;
              let i = gridHead[cellId];
              while (i !== -1) {
                const dx = pX[i] - r.x;
                const dy = pY[i] - r.y;
                if (dx * dx + dy * dy < r.radius * r.radius) {
                  pInRipple[i] = 1;
                }
                i = gridNext[i];
              }
            }
          }
        }
      }

      // Update Dark Matter
      for (let i = 0; i < DARK_MATTER_COUNT; i++) {
        if (dmActive[i] === 0) continue;

        dmX[i] += dmVX[i];
        dmY[i] += dmVY[i];

        if (dmX[i] < 0) { dmX[i] = 0; dmVX[i] *= -1; }
        if (dmX[i] > width) { dmX[i] = width; dmVX[i] *= -1; }
        if (dmY[i] < 0) { dmY[i] = 0; dmVY[i] *= -1; }
        if (dmY[i] > height) { dmY[i] = height; dmVY[i] *= -1; }

        dmVX[i] += (Math.random() - 0.5) * 2;
        dmVY[i] += (Math.random() - 0.5) * 2;

        const speed = Math.sqrt(dmVX[i] ** 2 + dmVY[i] ** 2);
        if (speed > 10) {
          dmVX[i] = (dmVX[i] / speed) * 10;
          dmVY[i] = (dmVY[i] / speed) * 10;
        }

        const age = now - dmBornTime[i];
        if (age > DM_LIFETIME) {
          dmActive[i] = 0;
        }
      }

      // Calculate Forces
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const typeI = pType[i];
        const rowOffset = typeI * TYPE_COUNT;

        const gx = (pX[i] / GRID_SIZE) | 0;
        const gy = (pY[i] / GRID_SIZE) | 0;

        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = gx + dx;
            const ny = gy + dy;

            if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows) {
              const cellId = ny * gridCols + nx;
              let j = gridHead[cellId];

              while (j !== -1) {
                if (i !== j) {
                  let dxVal = pX[j] - pX[i];
                  let dyVal = pY[j] - pY[i];

                  // Toroidal distance
                  if (dxVal > width * 0.5) dxVal -= width;
                  else if (dxVal < -width * 0.5) dxVal += width;
                  if (dyVal > height * 0.5) dyVal -= height;
                  else if (dyVal < -height * 0.5) dyVal += height;

                  const distSq = dxVal * dxVal + dyVal * dyVal;

                  if (distSq > 0 && distSq < NEARBY_RADIUS * NEARBY_RADIUS) {
                    const dist = Math.sqrt(distSq);

                    let fx = 0, fy = 0;

                    const minDist = pInRipple[i] ? MIN_DIST_RIPPLE : MIN_DIST;

                    if (dist < minDist) {
                      const force = REPULSION_STRENGTH * (1.0 - dist / minDist);
                      fx -= force * (dxVal / dist);
                      fy -= force * (dyVal / dist);
                    } else {
                      const typeJ = pType[j];
                      let force = matrix[rowOffset + typeJ];

                      force = force / (dist * 0.1);

                      if (distSq < CLOSE_RADIUS * CLOSE_RADIUS) force *= -0.2;
                      else if (distSq < INTERACTION_RADIUS * INTERACTION_RADIUS) force *= 2;

                      fx += force * (dxVal / dist);
                      fy += force * (dyVal / dist);
                    }

                    pVX[i] += fx;
                    pVY[i] += fy;
                  }
                }
                j = gridNext[j];
              }
            }
          }
        }

        // Dark Matter Repulsion
        for (let d = 0; d < DARK_MATTER_COUNT; d++) {
          if (dmActive[d]) {
            let dx = dmX[d] - pX[i];
            let dy = dmY[d] - pY[i];
            let dSq = dx * dx + dy * dy;
            if (dSq < DM_RADIUS * DM_RADIUS) {
              let dist = Math.sqrt(dSq);
              let rep = 2.0;
              pVX[i] -= (dx / dist) * rep;
              pVY[i] -= (dy / dist) * rep;
            }
          }
        }
      }

      // Spawn Ripples & Dark Matter
      if (now - lastRippleTime > 4000 && Math.random() < 0.05) {
        const rI = Math.floor(Math.random() * PARTICLE_COUNT);
        ripples.push({ x: pX[rI], y: pY[rI], radius: 0, opacity: 0.8 });
        lastRippleTime = now;

        for (let d = 0; d < DARK_MATTER_COUNT; d++) {
          if (!dmActive[d]) {
            dmActive[d] = 1;
            dmX[d] = pX[rI];
            dmY[d] = pY[rI];
            dmVX[d] = (Math.random() - 0.5) * 10;
            dmVY[d] = (Math.random() - 0.5) * 10;
            dmBornTime[d] = now;
            break;
          }
        }
      }
    }

    // ============ RENDERING ============

    function render() {
      // Step 1: Apply trail effect
      const readFB = currentTrailFB === 0 ? trailFB1 : trailFB2;
      const writeFB = currentTrailFB === 0 ? trailFB2 : trailFB1;
      const readTex = currentTrailFB === 0 ? trailTex1 : trailTex2;

      gl.bindFramebuffer(gl.FRAMEBUFFER, writeFB);
      gl.useProgram(trailProgram);

      const trailPosLoc = gl.getAttribLocation(trailProgram, 'a_position');
      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
      gl.enableVertexAttribArray(trailPosLoc);
      gl.vertexAttribPointer(trailPosLoc, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, readTex);
      gl.uniform1i(gl.getUniformLocation(trailProgram, 'u_texture'), 0);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Step 2: Draw particles
      gl.useProgram(particleProgram);

      // Upload particle positions
      const posData = new Float32Array(PARTICLE_COUNT * 2);
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        posData[i * 2] = pX[i];
        posData[i * 2 + 1] = pY[i];
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);

      const posLoc = gl.getAttribLocation(particleProgram, 'a_position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      // Upload colors
      const colorData = new Float32Array(PARTICLE_COUNT * 3);
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const color = COLORS[pType[i]];
        const brightness = pInRipple[i] ? 1.2 : 1.0;
        colorData[i * 3] = color[0] * brightness;
        colorData[i * 3 + 1] = color[1] * brightness;
        colorData[i * 3 + 2] = color[2] * brightness;
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.DYNAMIC_DRAW);

      const colorLoc = gl.getAttribLocation(particleProgram, 'a_color');
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

      gl.uniform2f(gl.getUniformLocation(particleProgram, 'u_resolution'), width, height);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);

      // Step 3: Draw dark matter
      if (dmActive.some(x => x)) {
        gl.useProgram(dmProgram);

        const activeDM = [];
        for (let i = 0; i < DARK_MATTER_COUNT; i++) {
          if (dmActive[i]) {
            activeDM.push(dmX[i], dmY[i]);
          }
        }

        if (activeDM.length > 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, dmBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(activeDM), gl.DYNAMIC_DRAW);

          const dmPosLoc = gl.getAttribLocation(dmProgram, 'a_position');
          gl.enableVertexAttribArray(dmPosLoc);
          gl.vertexAttribPointer(dmPosLoc, 2, gl.FLOAT, false, 0, 0);

          gl.uniform2f(gl.getUniformLocation(dmProgram, 'u_resolution'), width, height);

          gl.drawArrays(gl.POINTS, 0, activeDM.length / 2);
        }
      }

      gl.disable(gl.BLEND);

      // Step 4: Copy to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.useProgram(trailProgram);

      const writeTex = currentTrailFB === 0 ? trailTex2 : trailTex1;
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, writeTex);

      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
      gl.enableVertexAttribArray(trailPosLoc);
      gl.vertexAttribPointer(trailPosLoc, 2, gl.FLOAT, false, 0, 0);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Swap framebuffers
      currentTrailFB = 1 - currentTrailFB;
    }

    // ============ ANIMATION LOOP ============

    let frameCount = 0;
    let lastFpsTime = Date.now();
    let fps = 0;

    function animate() {
      updateMatrix();
      updatePhysics();
      render();

      // FPS counter
      frameCount++;
      const now = Date.now();
      if (now - lastFpsTime > 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFpsTime = now;
        document.getElementById('stats').innerHTML = `
          Particles: ${PARTICLE_COUNT.toLocaleString()}<br>
          FPS: ${fps}<br>
          Ripples: ${ripples.length}<br>
          Dark Matter: ${dmActive.filter(x => x).length}
        `;
      }

      requestAnimationFrame(animate);
    }

    // ============ EVENT HANDLERS ============

    canvas.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    });

    window.addEventListener('resize', () => {
      resize();
      gl.deleteFramebuffer(trailFB1);
      gl.deleteFramebuffer(trailFB2);
      gl.deleteTexture(trailTex1);
      gl.deleteTexture(trailTex2);
      initTrailFramebuffers();
    });

    // ============ START ============

    init();
    animate();

  </script>
</body>
</html>