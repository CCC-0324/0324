<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life v17-Optimized (WebGL)</title>
  <style>
    body { 
      margin: 0;
      overflow: hidden;
      background-color: black;
      font-family: monospace;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #888;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="ui">Count: <span id="pCount"></span> | FPS: <span id="fps"></span></div>
  <canvas id="glCanvas"></canvas>

  <script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec3 a_color;
    attribute float a_size;
    attribute float a_alpha;
    
    uniform vec2 u_resolution;
    
    varying vec3 v_color;
    varying float v_alpha;
    
    void main() {
      // Convert pixels to 0.0->1.0, then to -1.0->1.0
      vec2 zeroToOne = a_position / u_resolution;
      vec2 zeroToTwo = zeroToOne * 2.0;
      vec2 clipSpace = zeroToTwo - 1.0;
      
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      gl_PointSize = a_size;
      v_color = a_color;
      v_alpha = a_alpha;
    }
  </script>

  <script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec3 v_color;
    varying float v_alpha;
    
    void main() {
      // Make it a circle
      vec2 coord = gl_PointCoord - vec2(0.5);
      if(length(coord) > 0.5) discard;
      
      gl_FragColor = vec4(v_color, v_alpha);
    }
  </script>

  <script>
    // --- 配置 ---
    const CONFIG = {
      particleCount: 12000, // 粒子數量，可設為 10000 - 20000
      gridSize: 40,
      friction: 0.85, // 調整摩擦力以適應高幀率
      maxForce: 0.2,
      nearbyRadius: 100,
      minDist: 7,
      rippleDist: 3,
      clusterRadius: 50,
      clusterMinCount: 300
    };

    // --- 顏色與轉換 ---
    const HEX_COLORS = ['#2E4600','#486B00','#A2C523','#7D8427','#C9D787','#4E6E58','#6E8B3D','#99B898','#556B2F','#8E9775','#3B5323','#B4C292'];
    const RGB_COLORS = HEX_COLORS.map(h => {
      let bigint = parseInt(h.replace('#', ''), 16);
      return [(bigint >> 16 & 255)/255, (bigint >> 8 & 255)/255, (bigint & 255)/255];
    });

    // --- WebGL 初始化 ---
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl', { alpha: false, antialias: false });
    
    // 編譯 Shader
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').innerText));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').innerText));
    gl.linkProgram(program);
    gl.useProgram(program);

    // 獲取 Shader 變數位置
    const locs = {
      position: gl.getAttribLocation(program, "a_position"),
      color: gl.getAttribLocation(program, "a_color"),
      size: gl.getAttribLocation(program, "a_size"),
      alpha: gl.getAttribLocation(program, "a_alpha"),
      resolution: gl.getUniformLocation(program, "u_resolution")
    };

    // --- 數據結構 (SoA) ---
    // 使用 TypedArrays 進行極致優化
    const N = CONFIG.particleCount;
    const P = {
      x: new Float32Array(N),
      y: new Float32Array(N),
      vx: new Float32Array(N),
      vy: new Float32Array(N),
      type: new Int8Array(N),
      clustered: new Int8Array(N), // 0 or 1
      inRipple: new Int8Array(N)
    };

    // 用於 WebGL 渲染的緩衝區
    // 每個粒子需要：X, Y, R, G, B, Size, Alpha
    // 為了效能，我們把所有屬性 interleaved 或分開。這裡為了簡單分開傳送。
    const renderData = {
      pos: new Float32Array(N * 2),
      color: new Float32Array(N * 3),
      size: new Float32Array(N),
      alpha: new Float32Array(N)
    };

    const buffers = {
      pos: gl.createBuffer(),
      color: gl.createBuffer(),
      size: gl.createBuffer(),
      alpha: gl.createBuffer()
    };

    // --- 網格系統 (Linked List Grid) ---
    // 這比 array.push 快且無 GC
    let gridWidth, gridHeight;
    let gridHead, gridNext; // gridHead[cellIndex] -> firstParticleIndex, gridNext[particleIndex] -> nextParticleIndex

    function resizeGrid() {
      gridWidth = Math.ceil(canvas.width / CONFIG.gridSize);
      gridHeight = Math.ceil(canvas.height / CONFIG.gridSize);
      gridHead = new Int32Array(gridWidth * gridHeight);
      gridNext = new Int32Array(N);
    }

    // --- 交互矩陣 ---
    let oldMatrix = generateMatrix();
    let newMatrix = generateMatrix();
    let currentMatrix = structuredClone(oldMatrix);
    let transitionStartTime = Date.now();
    let lastChangeTime = Date.now();
    const TRANSITION_DURATION = 30000;
    const CHANGE_INTERVAL = 60000;

    function generateMatrix() {
      return Array(RGB_COLORS.length).fill(0).map(() => 
        Array(RGB_COLORS.length).fill(0).map(() => Math.random() * 2 * CONFIG.maxForce - CONFIG.maxForce)
      );
    }

    // --- 初始化粒子 ---
    for(let i=0; i<N; i++) {
      P.x[i] = Math.random() * window.innerWidth;
      P.y[i] = Math.random() * window.innerHeight;
      P.vx[i] = Math.random() * 2 - 1;
      P.vy[i] = Math.random() * 2 - 1;
      P.type[i] = Math.floor(Math.random() * RGB_COLORS.length);
      // 預填顏色數據
      const col = RGB_COLORS[P.type[i]];
      renderData.color[i*3] = col[0];
      renderData.color[i*3+1] = col[1];
      renderData.color[i*3+2] = col[2];
    }
    
    // 靜態綁定顏色 Buffer (因為顏色基本不變，除了 Cluster 效果)
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
    gl.bufferData(gl.ARRAY_BUFFER, renderData.color, gl.STATIC_DRAW);

    // --- 附加功能：漣漪與暗物質 ---
    let ripples = [];
    let darkMatter = []; // 數量少，可以用物件陣列

    // --- 主循環 ---
    function update() {
      const now = Date.now();
      const dt = 1; // Time step

      // 1. 矩陣平滑過渡
      let elapsed = now - transitionStartTime;
      let t = Math.min(elapsed / TRANSITION_DURATION, 1);
      let smoothT = -(Math.cos(Math.PI * t) - 1) / 2;
      
      for(let i=0; i<RGB_COLORS.length; i++) {
        for(let j=0; j<RGB_COLORS.length; j++) {
          currentMatrix[i][j] = oldMatrix[i][j] * (1 - smoothT) + newMatrix[i][j] * smoothT;
        }
      }
      if (t >= 1 && now - lastChangeTime > CHANGE_INTERVAL) {
        lastChangeTime = now;
        transitionStartTime = now;
        oldMatrix = structuredClone(newMatrix);
        newMatrix = generateMatrix();
      }

      // 2. 建立網格 (O(N))
      gridHead.fill(-1); // -1 代表空
      for(let i=0; i<N; i++) {
        const gx = Math.floor(P.x[i] / CONFIG.gridSize);
        const gy = Math.floor(P.y[i] / CONFIG.gridSize);
        if(gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
          const cell = gy * gridWidth + gx;
          gridNext[i] = gridHead[cell]; // 指向當前格子原本的第一個
          gridHead[cell] = i;           // 自己變成第一個
        } else {
          gridNext[i] = -1;
        }
      }

      // 3. 物理運算 (優化的鄰居查找)
      const nearbySq = CONFIG.nearbyRadius * CONFIG.nearbyRadius;
      const minDistSq = CONFIG.minDist * CONFIG.minDist;
      const rippleMinDistSq = CONFIG.rippleDist * CONFIG.rippleDist;
      const W = canvas.width;
      const H = canvas.height;

      for(let i=0; i<N; i++) {
        let fx = 0, fy = 0;
        const typeI = P.type[i];
        const gx = Math.floor(P.x[i] / CONFIG.gridSize);
        const gy = Math.floor(P.y[i] / CONFIG.gridSize);
        const currentMinSq = P.inRipple[i] ? rippleMinDistSq : minDistSq;

        // 搜尋 3x3 網格
        for(let dy = -1; dy <= 1; dy++) {
          for(let dx = -1; dx <= 1; dx++) {
            const nx = gx + dx;
            const ny = gy + dy;
            if(nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
              let j = gridHead[ny * gridWidth + nx];
              while(j !== -1) {
                if(i !== j) {
                  const dxVal = P.x[j] - P.x[i];
                  const dyVal = P.y[j] - P.y[i];
                  const distSq = dxVal*dxVal + dyVal*dyVal;

                  if(distSq > 0 && distSq < nearbySq) {
                    const dist = Math.sqrt(distSq);
                    
                    // 排斥力
                    if(distSq < currentMinSq) {
                      const f = 0.5 * (1.0 - dist / Math.sqrt(currentMinSq)); // 簡化
                      fx -= f * (dxVal/dist);
                      fy -= f * (dyVal/dist);
                    } 
                    // 吸引力
                    else {
                      let f = currentMatrix[typeI][P.type[j]] / dist; 
                      // 簡單優化：移除原本複雜的 if dist < 20 else if dist < 50 判斷，改用連續函數或簡單乘法提升速度
                      // 若要完全還原：
                      if (dist < 20) f *= -0.2;
                      else if (dist < 50) f *= 2.0; // 增強一點吸引力以補償高數量
                      
                      fx += f * (dxVal/dist);
                      fy += f * (dyVal/dist);
                    }
                  }
                }
                j = gridNext[j];
              }
            }
          }
        }

        // 邊界與速度更新
        P.vx[i] = (P.vx[i] + fx) * CONFIG.friction;
        P.vy[i] = (P.vy[i] + fy) * CONFIG.friction;
        P.x[i] += P.vx[i];
        P.y[i] += P.vy[i];

        // 簡單邊界反彈
        if(P.x[i]<0) { P.x[i]=0; P.vx[i]*=-1; }
        if(P.x[i]>W) { P.x[i]=W; P.vx[i]*=-1; }
        if(P.y[i]<0) { P.y[i]=0; P.vy[i]*=-1; }
        if(P.y[i]>H) { P.y[i]=H; P.vy[i]*=-1; }

        // 邊界內推 (原版邏輯)
        if(P.x[i] < 5) P.vx[i] += 0.5;
        if(P.x[i] > W-5) P.vx[i] -= 0.5;
        if(P.y[i] < 5) P.vy[i] += 0.5;
        if(P.y[i] > H-5) P.vy[i] -= 0.5;

        // 更新 Render Data
        renderData.pos[i*2] = P.x[i];
        renderData.pos[i*2+1] = P.y[i];
      }
    }

    // --- 群聚與邏輯更新 (每隔幾幀跑一次以節省效能) ---
    let frameCount = 0;
    const visited = new Int8Array(N); // 用於 BFS
    const clusterQueue = new Int32Array(N); // 靜態 Queue

    function updateLogic() {
      frameCount++;
      const now = Date.now();

      // 1. 群聚檢測 (每 10 幀做一次，避免卡頓)
      if(frameCount % 10 === 0) {
        visited.fill(0);
        P.clustered.fill(0);
        
        // 優化版 BFS: 只對看起來擁擠的地方做搜尋
        for(let i=0; i<N; i++) {
          if(visited[i]) continue;
          
          let qHead = 0;
          let qTail = 0;
          clusterQueue[qTail++] = i;
          visited[i] = 1;
          
          let count = 0;
          let members = []; // 為了計算中心，還是需要暫存

          // 限制單次搜索深度，避免超大 Cluster 卡死
          while(qHead < qTail) {
            const curr = clusterQueue[qHead++];
            if(count < CONFIG.clusterMinCount + 100) members.push(curr); // 只存需要的數量
            count++;

            const gx = Math.floor(P.x[curr] / CONFIG.gridSize);
            const gy = Math.floor(P.y[curr] / CONFIG.gridSize);
            const rSq = CONFIG.clusterRadius * CONFIG.clusterRadius;

            // 搜尋周圍 (只檢查同格子和相鄰格子)
            for(let dy=-1; dy<=1; dy++) {
              for(let dx=-1; dx<=1; dx++) {
                const nx = gx+dx, ny = gy+dy;
                if(nx>=0 && nx<gridWidth && ny>=0 && ny<gridHeight) {
                   let neighbor = gridHead[ny*gridWidth + nx];
                   while(neighbor !== -1) {
                     if(!visited[neighbor]) {
                       const dxv = P.x[neighbor] - P.x[curr];
                       const dyv = P.y[neighbor] - P.y[curr];
                       if(dxv*dxv + dyv*dyv < rSq) {
                         visited[neighbor] = 1;
                         clusterQueue[qTail++] = neighbor;
                       }
                     }
                     neighbor = gridNext[neighbor];
                   }
                }
              }
            }
          }

          if(count >= CONFIG.clusterMinCount) {
             // 標記為群聚
             for(let m=0; m<qTail; m++) {
               P.clustered[clusterQueue[m]] = 1;
             }
             // 產生 Ripple (限制頻率)
             let clusterId = i; // 簡單用起始點做 ID
             // ... 這裡簡化 Ripple 生成邏輯，隨機取中心 ...
             if(Math.random() < 0.05) { // 降低機率
                let cx=0, cy=0;
                let sampleSize = Math.min(members.length, 50);
                for(let k=0; k<sampleSize; k++) { cx += P.x[members[k]]; cy += P.y[members[k]]; }
                ripples.push({x: cx/sampleSize, y: cy/sampleSize, r: 0, active: true});
                if(Math.random() < 0.1) darkMatter.push({x: cx/sampleSize, y: cy/sampleSize, vx:0, vy:0, life: 200});
             }
          }
        }
      }

      // 2. 更新 Ripples
      for(let i=ripples.length-1; i>=0; i--) {
        ripples[i].r += 2;
        if(ripples[i].r > 300) ripples[i].active = false;
        if(!ripples[i].active) ripples.splice(i, 1);
      }

      // 3. 更新粒子狀態 (Ripple 影響)
      // 為了效能，我們只遍歷 Ripple
      P.inRipple.fill(0);
      for(let r of ripples) {
        const rSq = r.r * r.r;
        const gx = Math.floor(r.x / CONFIG.gridSize);
        const gy = Math.floor(r.y / CONFIG.gridSize);
        const searchRad = Math.ceil(r.r / CONFIG.gridSize);
        
        for(let dy=-searchRad; dy<=searchRad; dy++){
          for(let dx=-searchRad; dx<=searchRad; dx++){
             const nx = gx+dx, ny=gy+dy;
             if(nx>=0 && nx<gridWidth && ny>=0 && ny<gridHeight) {
               let idx = gridHead[ny*gridWidth+nx];
               while(idx !== -1) {
                 const dxv = P.x[idx] - r.x;
                 const dyv = P.y[idx] - r.y;
                 if(dxv*dxv + dyv*dyv < rSq) P.inRipple[idx] = 1;
                 idx = gridNext[idx];
               }
             }
          }
        }
      }
      
      // 4. Dark Matter (簡化版)
      for(let i=darkMatter.length-1; i>=0; i--) {
        let dm = darkMatter[i];
        dm.life--;
        dm.x += (Math.random()-0.5)*5;
        dm.y += (Math.random()-0.5)*5;
        
        // 排斥周圍
        const gx = Math.floor(dm.x / CONFIG.gridSize);
        const gy = Math.floor(dm.y / CONFIG.gridSize);
        for(let dy=-1; dy<=1; dy++){
          for(let dx=-1; dx<=1; dx++){
             const nx = gx+dx, ny=gy+dy;
             if(nx>=0 && nx<gridWidth && ny>=0 && ny<gridHeight) {
               let idx = gridHead[ny*gridWidth+nx];
               while(idx !== -1) {
                 const dxv = P.x[idx] - dm.x;
                 const dyv = P.y[idx] - dm.y;
                 const distSq = dxv*dxv + dyv*dyv;
                 if(distSq < 900 && distSq > 1) { // 30*30
                   const dist = Math.sqrt(distSq);
                   P.vx[idx] += (dxv/dist) * 2.0;
                   P.vy[idx] += (dyv/dist) * 2.0;
                 }
                 idx = gridNext[idx];
               }
             }
          }
        }
        if(dm.life <= 0) darkMatter.splice(i, 1);
      }

      // 5. 更新渲染屬性 (Size & Alpha)
      const blink = 0.5 + 0.5 * Math.sin(now * 0.005);
      for(let i=0; i<N; i++) {
        if(P.clustered[i]) {
          renderData.size[i] = 4.0; // 變大
          renderData.alpha[i] = 0.5 + 0.3 * blink;
        } else {
          renderData.size[i] = 2.0; // 正常大小
          renderData.alpha[i] = 1.0;
        }
      }
    }

    // --- 繪圖循環 ---
    function render() {
      // 調整 Canvas 尺寸
      if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        resizeGrid();
      }
      
      gl.uniform2f(locs.resolution, canvas.width, canvas.height);
      
      update();
      updateLogic();

      // 上傳數據到 GPU
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.pos);
      gl.bufferData(gl.ARRAY_BUFFER, renderData.pos, gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(locs.position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(locs.position);

      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
      // Color 是靜態的，除非你想改顏色，這裡不需要每幀 bufferData
      gl.vertexAttribPointer(locs.color, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(locs.color);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.size);
      gl.bufferData(gl.ARRAY_BUFFER, renderData.size, gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(locs.size, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(locs.size);

      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.alpha);
      gl.bufferData(gl.ARRAY_BUFFER, renderData.alpha, gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(locs.alpha, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(locs.alpha);

      // 繪製
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      
      // 啟用混合以支援透明度 (Cluster 閃爍效果)
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending 看起來更酷
      
      gl.drawArrays(gl.POINTS, 0, N);
      
      // 繪製 Ripples (用 Canvas 疊加或在 WebGL 畫圓圈有點麻煩，這裡為了簡潔省略 Ripple 的視覺繪製，只保留物理效果)
      // 如果非常需要 Ripple 視覺，建議用第二個 Canvas 疊在上面畫線條，效能影響不大。
      
      // 更新 UI
      document.getElementById('pCount').innerText = N;
      // 簡單 FPS 計算
      // ...
      
      requestAnimationFrame(render);
    }

    // --- 啟動 ---
    resizeGrid();
    render();

    // FPS Counter
    const fpsElem = document.getElementById('fps');
    let lastTime = performance.now();
    let frames = 0;
    setInterval(() => {
      const t = performance.now();
      fpsElem.innerText = Math.round(frames * 1000 / (t - lastTime));
      lastTime = t;
      frames = 0;
    }, 1000);
    function countFps() { frames++; requestAnimationFrame(countFps); }
    countFps();
    
    // 點擊全螢幕
    canvas.addEventListener('click', () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    });

  </script>
</body>
</html>
