<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life</title>
  <style>
    body { 
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #050505;
      overflow: hidden;
      font-family: monospace;
    }
    canvas {
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #486B00;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="stats"></div>
  <canvas id="particleCanvas"></canvas>
  <script>
    /**
     * Particle Life - High Performance Version
     * Optimization: 
     * 1. SoA (Structure of Arrays) with TypedArrays
     * 2. Spatial Hashing with Static Linked Lists (No GC)
     * 3. Math.sqrt removal where possible
     * 4. fillRect instead of arc
     */

    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha channel for slight perf boost if possible

    // Configuration
    let width, height;
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    resize();
    window.addEventListener('resize', resize);

    // Simulation Constants
    const PARTICLE_COUNT = 4000; // Increased from 3000 to 6000
    const COLORS = ['#2E4600','#486B00','#A2C523','#7D8427','#C9D787','#4E6E58','#6E8B3D','#99B898','#556B2F','#8E9775','#3B5323','#B4C292'];
    const TYPE_COUNT = COLORS.length;
    
    // Pre-calculate Colors as integer strings or reuse fillStyle efficiently
    const COLOR_STRINGS = COLORS; 
    const COLOR_RGB = COLORS.map(hexToRgb);

    // Physics Constants
    const FRICTION = 0.68; // 0.68
    const MAX_FORCE = 0.2;
    const REPULSION_STRENGTH = 0.5;
    
    // Distances (Squared for performance)
    const MIN_DIST_SQ = 7 * 7;
    const MIN_DIST_RIPPLE_SQ = 3 * 3;
    const NEARBY_RADIUS = 80; // Slightly reduced radius for better performance with high count
    const NEARBY_RADIUS_SQ = NEARBY_RADIUS * NEARBY_RADIUS;
    const INTERACTION_RADIUS_SQ = 50 * 50; 
    const CLOSE_RADIUS_SQ = 20 * 20;

    // Grid System Constants
    const GRID_SIZE = 40; // Cell size
    let gridCols = 0;
    let gridRows = 0;
    
    // --- Data Structures (SoA - Structure of Arrays) ---
    // Using Float32Array for physics is much faster than Array of Objects
    const pX = new Float32Array(PARTICLE_COUNT);
    const pY = new Float32Array(PARTICLE_COUNT);
    const pVX = new Float32Array(PARTICLE_COUNT);
    const pVY = new Float32Array(PARTICLE_COUNT);
    const pType = new Uint8Array(PARTICLE_COUNT);
    const pInRipple = new Uint8Array(PARTICLE_COUNT); // Boolean flag (0 or 1)
    
    // Grid Arrays (Linked List approach)
    // gridHead stores the index of the first particle in a cell
    // gridNext stores the index of the next particle in the chain
    let gridHead; 
    const gridNext = new Int32Array(PARTICLE_COUNT);

    // Interaction Matrices
    let matrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let targetMatrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    
    // State
    let lastChangeTime = Date.now();
    const CHANGE_INTERVAL = 60000;
    const TRANSITION_DURATION = 30000;
    
    // Ripples
    const ripples = [];
    let lastRippleTime = 0;

    // Dark Matter
    const DARK_MATTER_COUNT = 10; // Max concurrent dark matter
    const dmX = new Float32Array(DARK_MATTER_COUNT);
    const dmY = new Float32Array(DARK_MATTER_COUNT);
    const dmVX = new Float32Array(DARK_MATTER_COUNT);
    const dmVY = new Float32Array(DARK_MATTER_COUNT);
    const dmActive = new Uint8Array(DARK_MATTER_COUNT); // 0 = inactive, 1 = active
    const dmBornTime = new Float64Array(DARK_MATTER_COUNT);
    const DM_LIFETIME = 5000;
    const DM_RADIUS_SQ = 30 * 30;

    // --- Initialization ---

    function init() {
      // Initialize Particles
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pX[i] = Math.random() * width;
        pY[i] = Math.random() * height;
        pVX[i] = (Math.random() - 0.5);
        pVY[i] = (Math.random() - 0.5);
        pType[i] = Math.floor(Math.random() * TYPE_COUNT);
      }
      
      // Init Matrix
      randomizeMatrix(matrix);
      targetMatrix.set(matrix);
      
      // Init Grid
      initGrid();
    }

    function initGrid() {
      gridCols = Math.ceil(width / GRID_SIZE);
      gridRows = Math.ceil(height / GRID_SIZE);
      gridHead = new Int32Array(gridCols * gridRows);
    }

    function hexToRgb(hex) {
      let bigint = parseInt(hex.replace(/^#/, ''), 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }

    function randomizeMatrix(targetM) {
      for (let i = 0; i < TYPE_COUNT * TYPE_COUNT; i++) {
        targetM[i] = Math.random() * 2 * MAX_FORCE - MAX_FORCE;
      }
    }

    // --- Core Logic ---

    function updateMatrix() {
      const now = Date.now();
      const dt = now - lastChangeTime;
      
      // Matrix Transition
      if (now - lastChangeTime > CHANGE_INTERVAL) {
        // Start new transition
        matrix.set(targetMatrix); // Snap to old target (which is now current)
        randomizeMatrix(targetMatrix); // Generate new target
        lastChangeTime = now;
      } else if (dt < TRANSITION_DURATION) {
        // Interpolate
        // Not perfectly linear per frame but good enough for visual
        // Ideally we store oldMatrix, newMatrix and interp factor. 
        // For perf, we just nudge current towards target slowly
        for (let i = 0; i < matrix.length; i++) {
           matrix[i] += (targetMatrix[i] - matrix[i]) * 0.01; 
        }
      }
    }

    function updatePhysics() {
      // 1. Reset Grid
      gridHead.fill(-1);

      // 2. Move Particles & Insert into Grid
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Reset flags
        pInRipple[i] = 0;

        // Apply velocity
        pX[i] += pVX[i];
        pY[i] += pVY[i];

        // Boundary Wrap & Bounce (Hybrid)
        // Bounce off top/bottom
        if (pY[i] < 0) { pY[i] = 0; pVX[i] += (Math.random()-0.5); pVY[i] = Math.abs(pVY[i]); }
        if (pY[i] >= height) { pY[i] = height - 1; pVX[i] += (Math.random()-0.5); pVY[i] = -Math.abs(pVY[i]); }
        
        // Wrap Left/Right (Toroidal) for more fluid infinite feel
        if (pX[i] < 0) pX[i] += width;
        if (pX[i] >= width) pX[i] -= width;

        // Slight center pull if too close to edge (Legacy behavior kept for stability)
        if (pY[i] < 5) pVY[i] += 0.5;
        if (pY[i] > height - 5) pVY[i] -= 0.5;

        // Friction
        pVX[i] *= FRICTION;
        pVY[i] *= FRICTION;

        // Grid Insertion
        // Fast floor
        const gx = (pX[i] / GRID_SIZE) | 0; 
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows) {
          const cellId = gy * gridCols + gx;
          gridNext[i] = gridHead[cellId];
          gridHead[cellId] = i;
        } else {
          // Safety net for out of bounds
          gridNext[i] = -1;
        }
      }

      // 3. Ripple & Dark Matter Logic
      const now = Date.now();
      
      // Update Ripples
      for (let r = ripples.length - 1; r >= 0; r--) {
        const ripple = ripples[r];
        ripple.radius += 2;
        ripple.opacity -= 0.01;
        
        if (ripple.opacity <= 0) {
          ripples.splice(r, 1);
          continue;
        }

        // Check particles in ripple
        const rSq = ripple.radius * ripple.radius;
        // Optimization: We don't loop all particles here. 
        // We handle ripple effect inside the interaction loop implicitly or simplistic check
        // For exact "inRippleArea" flag, we need distance. 
        // To save perf, we do a quick check in the interaction loop if needed, 
        // OR we just accept ripples are visual mostly.
        // Let's keep it simple: We won't iterate 6000 particles just for ripple flags.
        // We will calc it inside the neighbor loop if close to ripple center? No, that's complex.
        // We will iterate ONLY if ripples exist.
      }
      
      // If ripples exist, mark particles (Costly but necessary for the specific feature)
      if (ripples.length > 0) {
         for (let i = 0; i < PARTICLE_COUNT; i++) {
            for (let r of ripples) {
               const dx = pX[i] - r.x;
               const dy = pY[i] - r.y;
               if (dx*dx + dy*dy < r.radius * r.radius) {
                 pInRipple[i] = 1;
                 break;
               }
            }
         }
      }

      // Update Dark Matter
      for (let i = 0; i < DARK_MATTER_COUNT; i++) {
        if (dmActive[i] === 0) continue;
        
        // Move
        dmX[i] += dmVX[i];
        dmY[i] += dmVY[i];
        
        // Bounce
        if (dmX[i] < 0 || dmX[i] > width) dmVX[i] *= -1;
        if (dmY[i] < 0 || dmY[i] > height) dmVY[i] *= -1;
        
        // Chaos move
        dmVX[i] += (Math.random() - 0.5) * 2;
        dmVY[i] += (Math.random() - 0.5) * 2;
        
        // Limit speed
        const speed = Math.sqrt(dmVX[i]**2 + dmVY[i]**2);
        if (speed > 10) { dmVX[i] = (dmVX[i]/speed)*10; dmVY[i] = (dmVY[i]/speed)*10; }

        // Lifetime
        const age = now - dmBornTime[i];
        if (age > DM_LIFETIME) {
          dmActive[i] = 0;
        }
      }

      // 4. Calculate Forces (The heavy lifting)
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const typeI = pType[i];
        const rowOffset = typeI * TYPE_COUNT; // Cache matrix row for type I
        
        const gx = (pX[i] / GRID_SIZE) | 0;
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        // Neighbor Search (3x3 grid)
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = gx + dx;
            const ny = gy + dy;
            
            if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows) {
              const cellId = ny * gridCols + nx;
              let j = gridHead[cellId];
              
              // Traverse Linked List in this cell
              while (j !== -1) {
                if (i !== j) {
                  let dxVal = pX[j] - pX[i];
                  let dyVal = pY[j] - pY[i];
                  
                  // Toroidal Wrap distance adjustment
                  if (dxVal > width * 0.5) dxVal -= width;
                  else if (dxVal < -width * 0.5) dxVal += width;
                  
                  const distSq = dxVal*dxVal + dyVal*dyVal;
                  
                  if (distSq > 0 && distSq < NEARBY_RADIUS_SQ) {
                    const dist = Math.sqrt(distSq); // Need sqrt for normalization :(
                    
                    let fx = 0, fy = 0;
                    
                    // Repulsion
                    const minDistSq = pInRipple[i] ? MIN_DIST_RIPPLE_SQ : MIN_DIST_SQ;
                    
                    if (distSq < minDistSq) {
                      // Strong repulsion
                      const force = REPULSION_STRENGTH * (1.0 - dist / Math.sqrt(minDistSq));
                      fx -= force * (dxVal / dist);
                      fy -= force * (dyVal / dist);
                    } else {
                      // Interaction Force
                      // Matrix value lookup
                      const typeJ = pType[j];
                      let force = matrix[rowOffset + typeJ]; // Flattened 2D access
                      
                      // Distance Factor
                      // force = force / (dist * 0.1) -> original logic roughly
                      force = force / (dist * 0.1); 

                      if (distSq < CLOSE_RADIUS_SQ) force *= -0.2; // Close range repulsion
                      else if (distSq < INTERACTION_RADIUS_SQ) force *= 2; // Medium range boost

                      fx += force * (dxVal / dist);
                      fy += force * (dyVal / dist);
                    }
                    
                    pVX[i] += fx;
                    pVY[i] += fy;
                  }
                }
                j = gridNext[j];
              }
            }
          }
        }
        
        // Dark Matter Repulsion (Simplified)
        for (let d = 0; d < DARK_MATTER_COUNT; d++) {
           if (dmActive[d]) {
             let dx = dmX[d] - pX[i];
             let dy = dmY[d] - pY[i];
             let dSq = dx*dx + dy*dy;
             if (dSq < DM_RADIUS_SQ) {
               let dist = Math.sqrt(dSq);
               let rep = 2.0; // Strong push
               pVX[i] -= (dx/dist) * rep;
               pVY[i] -= (dy/dist) * rep;
             }
           }
        }
      }

      // Randomly spawn Ripples & Dark Matter
      if (now - lastRippleTime > 4000 && Math.random() < 0.05) {
         // Pick a random active area
         const rI = Math.floor(Math.random() * PARTICLE_COUNT);
         ripples.push({x: pX[rI], y: pY[rI], radius: 0, opacity: 0.8});
         lastRippleTime = now;
         
         // Spawn Dark Matter
         for(let d=0; d<DARK_MATTER_COUNT; d++){
           if(!dmActive[d]) {
             dmActive[d] = 1;
             dmX[d] = pX[rI];
             dmY[d] = pY[rI];
             dmVX[d] = (Math.random()-0.5)*10;
             dmVY[d] = (Math.random()-0.5)*10;
             dmBornTime[d] = now;
             break;
           }
         }
      }
    }

    function draw() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail
      ctx.fillRect(0, 0, width, height);
      
      // Draw Ripples
      ctx.lineWidth = 2;
      for (const r of ripples) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(50, 80, 50, ${r.opacity})`;
        ctx.stroke();
      }

      // Draw Dark Matter
      ctx.fillStyle = "#000000";
      for(let i=0; i<DARK_MATTER_COUNT; i++){
        if(dmActive[i]) {
          ctx.beginPath();
          ctx.arc(dmX[i], dmY[i], 4, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "#000000";
          ctx.stroke();
        }
      }

      // Draw Particles (Optimized)
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Fast Color Lookup
        ctx.fillStyle = COLOR_STRINGS[pType[i]];
        
        // fillRect is significantly faster than arc
        // Using 2x2 rect to mimic small dot
        ctx.fillRect(pX[i], pY[i], 2, 2); 
      }
    }

    function animate() {
      updateMatrix();
      updatePhysics();
      draw();
      requestAnimationFrame(animate);
    }

    // Handle Window Resize re-init grid
    window.addEventListener('resize', () => {
        resize();
        initGrid();
    });

    // Start
    init();
    animate();

    // Click for Fullscreen
    canvas.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    });

  </script>
</body>
</html>