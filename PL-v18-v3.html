<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Life</title>
  <style>
    body { 
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000000;
      overflow: hidden;
      font-family: monospace;
    }
    canvas {
      /* Removed box-shadow for a cleaner, full-screen look */
    }
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #486B00;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="stats"></div>
  <canvas id="particleCanvas"></canvas>
  <script>

    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); 

    // Configuration
    let width, height;
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    resize();
    window.addEventListener('resize', resize);

    // Simulation Constants (Values from original file)
    const PARTICLE_COUNT = 10000;
    const COLORS = ['#2E4600','#486B00','#A2C523','#7D8427','#C9D787','#4E6E58','#6E8B3D','#99B898','#556B2F','#8E9775','#3B5323','#B4C292'];
    const TYPE_COUNT = COLORS.length;
    
    const COLOR_STRINGS = COLORS; 

    // Physics Constants
    const FRICTION = 0.68;
    const MAX_FORCE = 0.2;
    const REPULSION_STRENGTH = 0.5;
    
    // Distances (Squared for performance)
    const MIN_DIST_SQ = 7 * 7;
    const MIN_DIST_RIPPLE_SQ = 3 * 3;
    const NEARBY_RADIUS = 80;
    const NEARBY_RADIUS_SQ = NEARBY_RADIUS * NEARBY_RADIUS;
    const INTERACTION_RADIUS_SQ = 50 * 50; 
    const CLOSE_RADIUS_SQ = 20 * 20;

    // Grid System Constants
    const GRID_SIZE = 40;
    let gridCols = 0;
    let gridRows = 0;
    
    // --- Data Structures (SoA - Structure of Arrays) ---
    const pX = new Float32Array(PARTICLE_COUNT);
    const pY = new Float32Array(PARTICLE_COUNT);
    const pVX = new Float32Array(PARTICLE_COUNT);
    const pVY = new Float32Array(PARTICLE_COUNT);
    const pType = new Uint8Array(PARTICLE_COUNT);
    const pInRipple = new Uint8Array(PARTICLE_COUNT);
    
    let gridHead; 
    const gridNext = new Int32Array(PARTICLE_COUNT);

    // Interaction Matrices
    let matrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    let targetMatrix = new Float32Array(TYPE_COUNT * TYPE_COUNT);
    
    // State
    let lastChangeTime = Date.now();
    const CHANGE_INTERVAL = 60000;
    const TRANSITION_DURATION = 30000;
    
    // Ripples
    const ripples = [];
    let lastRippleTime = 0;

    // Dark Matter
    const DARK_MATTER_COUNT = 10;
    const dmX = new Float32Array(DARK_MATTER_COUNT);
    const dmY = new Float32Array(DARK_MATTER_COUNT);
    const dmVX = new Float32Array(DARK_MATTER_COUNT);
    const dmVY = new Float32Array(DARK_MATTER_COUNT);
    const dmActive = new Uint8Array(DARK_MATTER_COUNT);
    const dmBornTime = new Float64Array(DARK_MATTER_COUNT);
    const DM_LIFETIME = 5000;
    const DM_RADIUS_SQ = 30 * 30;

    // --- Initialization ---

    function init() {
      // Initialize Particles
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pX[i] = Math.random() * width;
        pY[i] = Math.random() * height;
        pVX[i] = (Math.random() - 0.5);
        pVY[i] = (Math.random() - 0.5);
        pType[i] = Math.floor(Math.random() * TYPE_COUNT);
      }
      
      // Init Matrix
      randomizeMatrix(matrix);
      targetMatrix.set(matrix);
      
      // Init Grid
      initGrid();
    }

    function initGrid() {
      gridCols = Math.ceil(width / GRID_SIZE);
      gridRows = Math.ceil(height / GRID_SIZE);
      gridHead = new Int32Array(gridCols * gridRows);
    }

    function randomizeMatrix(targetM) {
      for (let i = 0; i < TYPE_COUNT * TYPE_COUNT; i++) {
        targetM[i] = Math.random() * 2 * MAX_FORCE - MAX_FORCE;
      }
    }

    // --- Core Logic ---

    function updateMatrix() {
      const now = Date.now();
      const dt = now - lastChangeTime;
      
      // Matrix Transition
      if (now - lastChangeTime > CHANGE_INTERVAL) {
        matrix.set(targetMatrix);
        randomizeMatrix(targetMatrix);
        lastChangeTime = now;
      } else if (dt < TRANSITION_DURATION) {
        for (let i = 0; i < matrix.length; i++) {
           matrix[i] += (targetMatrix[i] - matrix[i]) * 0.01; 
        }
      }
    }

    function updatePhysics() {
      // 1. Reset Grid
      gridHead.fill(-1);

      // 2. Move Particles & Insert into Grid
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        pInRipple[i] = 0;

        // Apply velocity
        pX[i] += pVX[i];
        pY[i] += pVY[i];

        // --- TOROIDAL WRAP BOUNDARY (Full Screen) ---
        // Wrap X
        if (pX[i] < 0) pX[i] += width;
        else if (pX[i] >= width) pX[i] -= width;
        
        // Wrap Y (Modified from original Bounce/Pull to Toroidal Wrap)
        if (pY[i] < 0) pY[i] += height;
        else if (pY[i] >= height) pY[i] -= height;
        // ---------------------------------------------

        // Friction
        pVX[i] *= FRICTION;
        pVY[i] *= FRICTION;

        // Grid Insertion
        const gx = (pX[i] / GRID_SIZE) | 0; 
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        if (gx >= 0 && gx < gridCols && gy >= 0 && gy < gridRows) {
          const cellId = gy * gridCols + gx;
          gridNext[i] = gridHead[cellId];
          gridHead[cellId] = i;
        } else {
          // Safety net for out of bounds
          gridNext[i] = -1;
        }
      }

      // 3. Ripple & Dark Matter Logic (Unchanged)
      const now = Date.now();
      
      // Update Ripples
      for (let r = ripples.length - 1; r >= 0; r--) {
        const ripple = ripples[r];
        ripple.radius += 2;
        ripple.opacity -= 0.01;
        
        if (ripple.opacity <= 0) {
          ripples.splice(r, 1);
          continue;
        }
      }
      
      // If ripples exist, mark particles (Costly but necessary for the specific feature)
      if (ripples.length > 0) {
         for (let i = 0; i < PARTICLE_COUNT; i++) {
            for (let r of ripples) {
               const dx = pX[i] - r.x;
               const dy = pY[i] - r.y;
               if (dx*dx + dy*dy < r.radius * r.radius) {
                 pInRipple[i] = 1;
                 break;
               }
            }
         }
      }

      // Update Dark Matter
      for (let i = 0; i < DARK_MATTER_COUNT; i++) {
        if (dmActive[i] === 0) continue;
        
        // Move
        dmX[i] += dmVX[i];
        dmY[i] += dmVY[i];
        
        // Bounce off bounds (Dark Matter is not toroidal)
        if (dmX[i] < 0) { dmX[i] = 0; dmVX[i] *= -1; }
        if (dmX[i] > width) { dmX[i] = width; dmVX[i] *= -1; }
        if (dmY[i] < 0) { dmY[i] = 0; dmVY[i] *= -1; }
        if (dmY[i] > height) { dmY[i] = height; dmVY[i] *= -1; }

        // Chaos move
        dmVX[i] += (Math.random() - 0.5) * 2;
        dmVY[i] += (Math.random() - 0.5) * 2;
        
        // Limit speed
        const speed = Math.sqrt(dmVX[i]**2 + dmVY[i]**2);
        if (speed > 10) { dmVX[i] = (dmVX[i]/speed)*10; dmVY[i] = (dmVY[i]/speed)*10; }

        // Lifetime
        const age = now - dmBornTime[i];
        if (age > DM_LIFETIME) {
          dmActive[i] = 0;
        }
      }

      // 4. Calculate Forces (The heavy lifting)
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const typeI = pType[i];
        const rowOffset = typeI * TYPE_COUNT;
        
        const gx = (pX[i] / GRID_SIZE) | 0;
        const gy = (pY[i] / GRID_SIZE) | 0;
        
        // Neighbor Search (3x3 grid)
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = gx + dx;
            const ny = gy + dy;
            
            // Note: We check grid bounds but particle distance calculation 
            // handles the toroidal wrap for force.
            if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows) {
              const cellId = ny * gridCols + nx;
              let j = gridHead[cellId];
              
              // Traverse Linked List in this cell
              while (j !== -1) {
                if (i !== j) {
                  let dxVal = pX[j] - pX[i];
                  let dyVal = pY[j] - pY[i];
                  
                  // --- TOROIDAL WRAP DISTANCE ADJUSTMENT ---
                  // This ensures particles at opposite sides of the screen interact correctly.
                  if (dxVal > width * 0.5) dxVal -= width;
                  else if (dxVal < -width * 0.5) dxVal += width;
                  
                  if (dyVal > height * 0.5) dyVal -= height;
                  else if (dyVal < -height * 0.5) dyVal += height;
                  // -----------------------------------------
                  
                  const distSq = dxVal*dxVal + dyVal*dyVal;
                  
                  if (distSq > 0 && distSq < NEARBY_RADIUS_SQ) {
                    const dist = Math.sqrt(distSq);
                    
                    let fx = 0, fy = 0;
                    
                    // Repulsion
                    const minDistSq = pInRipple[i] ? MIN_DIST_RIPPLE_SQ : MIN_DIST_SQ;
                    
                    if (distSq < minDistSq) {
                      // Strong repulsion
                      const force = REPULSION_STRENGTH * (1.0 - dist / Math.sqrt(minDistSq));
                      fx -= force * (dxVal / dist);
                      fy -= force * (dyVal / dist);
                    } else {
                      // Interaction Force
                      const typeJ = pType[j];
                      let force = matrix[rowOffset + typeJ];
                      
                      // Distance Factor
                      force = force / (dist * 0.1); 

                      if (distSq < CLOSE_RADIUS_SQ) force *= -0.2;
                      else if (distSq < INTERACTION_RADIUS_SQ) force *= 2;

                      fx += force * (dxVal / dist);
                      fy += force * (dyVal / dist);
                    }
                    
                    pVX[i] += fx;
                    pVY[i] += fy;
                  }
                }
                j = gridNext[j];
              }
            }
          }
        }
        
        // Dark Matter Repulsion (Simplified) (Unchanged)
        for (let d = 0; d < DARK_MATTER_COUNT; d++) {
           if (dmActive[d]) {
             let dx = dmX[d] - pX[i];
             let dy = dmY[d] - pY[i];
             let dSq = dx*dx + dy*dy;
             if (dSq < DM_RADIUS_SQ) {
               let dist = Math.sqrt(dSq);
               let rep = 2.0;
               pVX[i] -= (dx/dist) * rep;
               pVY[i] -= (dy/dist) * rep;
             }
           }
        }
      }

      // Randomly spawn Ripples & Dark Matter (Unchanged)
      if (now - lastRippleTime > 4000 && Math.random() < 0.05) {
         const rI = Math.floor(Math.random() * PARTICLE_COUNT);
         ripples.push({x: pX[rI], y: pY[rI], radius: 0, opacity: 0.8});
         lastRippleTime = now;
         
         for(let d=0; d<DARK_MATTER_COUNT; d++){
           if(!dmActive[d]) {
             dmActive[d] = 1;
             dmX[d] = pX[rI];
             dmY[d] = pY[rI];
             dmVX[d] = (Math.random()-0.5)*10;
             dmVY[d] = (Math.random()-0.5)*10;
             dmBornTime[d] = now;
             break;
           }
         }
      }
    }

    function draw() {
      // Clear with trail effect
      ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
      ctx.fillRect(0, 0, width, height);
      
      // Draw Ripples (Unchanged)
      ctx.lineWidth = 2;
      for (const r of ripples) {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(0, 0, 0, ${r.opacity})`;
        ctx.stroke();
      }

      // Draw Dark Matter (Unchanged)
      ctx.fillStyle = "#000000";
      for(let i=0; i<DARK_MATTER_COUNT; i++){
        if(dmActive[i]) {
          ctx.beginPath();
          ctx.arc(dmX[i], dmY[i], 4, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "#000000";
          ctx.stroke();
        }
      }

      // Draw Particles (Optimized) (Unchanged)
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        ctx.fillStyle = COLOR_STRINGS[pType[i]];
        ctx.fillRect(pX[i], pY[i], 2, 2); 
      }
    }

    function animate() {
      updateMatrix();
      updatePhysics();
      draw();
      requestAnimationFrame(animate);
    }

    // Handle Window Resize re-init grid
    window.addEventListener('resize', () => {
        resize();
        initGrid();
    });

    // Start
    init();
    animate();

    // Click for Fullscreen (Unchanged)
    canvas.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    });

  </script>
</body>
</html>